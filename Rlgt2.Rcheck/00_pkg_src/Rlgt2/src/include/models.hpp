
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#include <rstan/rstaninc.hpp>
// Code generated by Stan version 2.16.0

#include <stan/model/model_header.hpp>

namespace model_LGTe_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_LGTe");
    reader.add_event(53, 53, "end", "model_LGTe");
    return reader;
}

class model_LGTe : public prob_grad {
private:
    double CAUCHY_SD;
    double MIN_POW_TREND;
    double MAX_POW_TREND;
    double MIN_SIGMA;
    double MIN_NU;
    double MAX_NU;
    int N;
    vector_d y;
    double POW_TREND_ALPHA;
    double POW_TREND_BETA;
public:
    model_LGTe(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_LGTe(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_LGTe_namespace::model_LGTe";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        context__.validate_dims("data initialization", "CAUCHY_SD", "double", context__.to_vec());
        CAUCHY_SD = double(0);
        vals_r__ = context__.vals_r("CAUCHY_SD");
        pos__ = 0;
        CAUCHY_SD = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MIN_POW_TREND", "double", context__.to_vec());
        MIN_POW_TREND = double(0);
        vals_r__ = context__.vals_r("MIN_POW_TREND");
        pos__ = 0;
        MIN_POW_TREND = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MAX_POW_TREND", "double", context__.to_vec());
        MAX_POW_TREND = double(0);
        vals_r__ = context__.vals_r("MAX_POW_TREND");
        pos__ = 0;
        MAX_POW_TREND = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MIN_SIGMA", "double", context__.to_vec());
        MIN_SIGMA = double(0);
        vals_r__ = context__.vals_r("MIN_SIGMA");
        pos__ = 0;
        MIN_SIGMA = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MIN_NU", "double", context__.to_vec());
        MIN_NU = double(0);
        vals_r__ = context__.vals_r("MIN_NU");
        pos__ = 0;
        MIN_NU = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MAX_NU", "double", context__.to_vec());
        MAX_NU = double(0);
        vals_r__ = context__.vals_r("MAX_NU");
        pos__ = 0;
        MAX_NU = vals_r__[pos__++];
        context__.validate_dims("data initialization", "N", "int", context__.to_vec());
        N = int(0);
        vals_i__ = context__.vals_i("N");
        pos__ = 0;
        N = vals_i__[pos__++];
        validate_non_negative_index("y", "N", N);
        context__.validate_dims("data initialization", "y", "vector_d", context__.to_vec(N));
        validate_non_negative_index("y", "N", N);
        y = vector_d(static_cast<Eigen::VectorXd::Index>(N));
        vals_r__ = context__.vals_r("y");
        pos__ = 0;
        size_t y_i_vec_lim__ = N;
        for (size_t i_vec__ = 0; i_vec__ < y_i_vec_lim__; ++i_vec__) {
            y[i_vec__] = vals_r__[pos__++];
        }
        context__.validate_dims("data initialization", "POW_TREND_ALPHA", "double", context__.to_vec());
        POW_TREND_ALPHA = double(0);
        vals_r__ = context__.vals_r("POW_TREND_ALPHA");
        pos__ = 0;
        POW_TREND_ALPHA = vals_r__[pos__++];
        context__.validate_dims("data initialization", "POW_TREND_BETA", "double", context__.to_vec());
        POW_TREND_BETA = double(0);
        vals_r__ = context__.vals_r("POW_TREND_BETA");
        pos__ = 0;
        POW_TREND_BETA = vals_r__[pos__++];

        // validate, data variables
        check_greater_or_equal(function__,"CAUCHY_SD",CAUCHY_SD,0);
        check_greater_or_equal(function__,"MIN_SIGMA",MIN_SIGMA,0);
        check_greater_or_equal(function__,"MIN_NU",MIN_NU,1);
        check_greater_or_equal(function__,"MAX_NU",MAX_NU,1);
        check_greater_or_equal(function__,"N",N,1);
        check_greater_or_equal(function__,"y",y,0);
        check_greater_or_equal(function__,"POW_TREND_ALPHA",POW_TREND_ALPHA,0);
        check_greater_or_equal(function__,"POW_TREND_BETA",POW_TREND_BETA,0);
        // initialize data variables

        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed data

        // validate, set parameter ranges
        num_params_r__ = 0U;
        param_ranges_i__.clear();
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
    }

    ~model_LGTe() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("nu")))
            throw std::runtime_error("variable nu missing");
        vals_r__ = context__.vals_r("nu");
        pos__ = 0U;
        context__.validate_dims("initialization", "nu", "double", context__.to_vec());
        // generate_declaration nu
        double nu(0);
        nu = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(MIN_NU,MAX_NU,nu);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable nu: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma", "double", context__.to_vec());
        // generate_declaration sigma
        double sigma(0);
        sigma = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("levSm")))
            throw std::runtime_error("variable levSm missing");
        vals_r__ = context__.vals_r("levSm");
        pos__ = 0U;
        context__.validate_dims("initialization", "levSm", "double", context__.to_vec());
        // generate_declaration levSm
        double levSm(0);
        levSm = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,levSm);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable levSm: ") + e.what());
        }

        if (!(context__.contains_r("bSm")))
            throw std::runtime_error("variable bSm missing");
        vals_r__ = context__.vals_r("bSm");
        pos__ = 0U;
        context__.validate_dims("initialization", "bSm", "double", context__.to_vec());
        // generate_declaration bSm
        double bSm(0);
        bSm = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,bSm);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable bSm: ") + e.what());
        }

        if (!(context__.contains_r("bInit")))
            throw std::runtime_error("variable bInit missing");
        vals_r__ = context__.vals_r("bInit");
        pos__ = 0U;
        context__.validate_dims("initialization", "bInit", "double", context__.to_vec());
        // generate_declaration bInit
        double bInit(0);
        bInit = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(bInit);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable bInit: ") + e.what());
        }

        if (!(context__.contains_r("powTrendBeta")))
            throw std::runtime_error("variable powTrendBeta missing");
        vals_r__ = context__.vals_r("powTrendBeta");
        pos__ = 0U;
        context__.validate_dims("initialization", "powTrendBeta", "double", context__.to_vec());
        // generate_declaration powTrendBeta
        double powTrendBeta(0);
        powTrendBeta = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,powTrendBeta);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable powTrendBeta: ") + e.what());
        }

        if (!(context__.contains_r("coefTrend")))
            throw std::runtime_error("variable coefTrend missing");
        vals_r__ = context__.vals_r("coefTrend");
        pos__ = 0U;
        context__.validate_dims("initialization", "coefTrend", "double", context__.to_vec());
        // generate_declaration coefTrend
        double coefTrend(0);
        coefTrend = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(coefTrend);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable coefTrend: ") + e.what());
        }

        if (!(context__.contains_r("offsetSigma")))
            throw std::runtime_error("variable offsetSigma missing");
        vals_r__ = context__.vals_r("offsetSigma");
        pos__ = 0U;
        context__.validate_dims("initialization", "offsetSigma", "double", context__.to_vec());
        // generate_declaration offsetSigma
        double offsetSigma(0);
        offsetSigma = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(MIN_SIGMA,offsetSigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable offsetSigma: ") + e.what());
        }

        if (!(context__.contains_r("locTrendFract")))
            throw std::runtime_error("variable locTrendFract missing");
        vals_r__ = context__.vals_r("locTrendFract");
        pos__ = 0U;
        context__.validate_dims("initialization", "locTrendFract", "double", context__.to_vec());
        // generate_declaration locTrendFract
        double locTrendFract(0);
        locTrendFract = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(-(0.25),1,locTrendFract);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable locTrendFract: ") + e.what());
        }

        if (!(context__.contains_r("innovSm")))
            throw std::runtime_error("variable innovSm missing");
        vals_r__ = context__.vals_r("innovSm");
        pos__ = 0U;
        context__.validate_dims("initialization", "innovSm", "double", context__.to_vec());
        // generate_declaration innovSm
        double innovSm(0);
        innovSm = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,innovSm);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable innovSm: ") + e.what());
        }

        if (!(context__.contains_r("innovSizeInit")))
            throw std::runtime_error("variable innovSizeInit missing");
        vals_r__ = context__.vals_r("innovSizeInit");
        pos__ = 0U;
        context__.validate_dims("initialization", "innovSizeInit", "double", context__.to_vec());
        // generate_declaration innovSizeInit
        double innovSizeInit(0);
        innovSizeInit = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,innovSizeInit);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable innovSizeInit: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        // model parameters
        stan::io::reader<T__> in__(params_r__,params_i__);

        T__ nu;
        (void) nu;  // dummy to suppress unused var warning
        if (jacobian__)
            nu = in__.scalar_lub_constrain(MIN_NU,MAX_NU,lp__);
        else
            nu = in__.scalar_lub_constrain(MIN_NU,MAX_NU);

        T__ sigma;
        (void) sigma;  // dummy to suppress unused var warning
        if (jacobian__)
            sigma = in__.scalar_lb_constrain(0,lp__);
        else
            sigma = in__.scalar_lb_constrain(0);

        T__ levSm;
        (void) levSm;  // dummy to suppress unused var warning
        if (jacobian__)
            levSm = in__.scalar_lub_constrain(0,1,lp__);
        else
            levSm = in__.scalar_lub_constrain(0,1);

        T__ bSm;
        (void) bSm;  // dummy to suppress unused var warning
        if (jacobian__)
            bSm = in__.scalar_lub_constrain(0,1,lp__);
        else
            bSm = in__.scalar_lub_constrain(0,1);

        T__ bInit;
        (void) bInit;  // dummy to suppress unused var warning
        if (jacobian__)
            bInit = in__.scalar_constrain(lp__);
        else
            bInit = in__.scalar_constrain();

        T__ powTrendBeta;
        (void) powTrendBeta;  // dummy to suppress unused var warning
        if (jacobian__)
            powTrendBeta = in__.scalar_lub_constrain(0,1,lp__);
        else
            powTrendBeta = in__.scalar_lub_constrain(0,1);

        T__ coefTrend;
        (void) coefTrend;  // dummy to suppress unused var warning
        if (jacobian__)
            coefTrend = in__.scalar_constrain(lp__);
        else
            coefTrend = in__.scalar_constrain();

        T__ offsetSigma;
        (void) offsetSigma;  // dummy to suppress unused var warning
        if (jacobian__)
            offsetSigma = in__.scalar_lb_constrain(MIN_SIGMA,lp__);
        else
            offsetSigma = in__.scalar_lb_constrain(MIN_SIGMA);

        T__ locTrendFract;
        (void) locTrendFract;  // dummy to suppress unused var warning
        if (jacobian__)
            locTrendFract = in__.scalar_lub_constrain(-(0.25),1,lp__);
        else
            locTrendFract = in__.scalar_lub_constrain(-(0.25),1);

        T__ innovSm;
        (void) innovSm;  // dummy to suppress unused var warning
        if (jacobian__)
            innovSm = in__.scalar_lub_constrain(0,1,lp__);
        else
            innovSm = in__.scalar_lub_constrain(0,1);

        T__ innovSizeInit;
        (void) innovSizeInit;  // dummy to suppress unused var warning
        if (jacobian__)
            innovSizeInit = in__.scalar_lb_constrain(0,lp__);
        else
            innovSizeInit = in__.scalar_lb_constrain(0);


        // transformed parameters
        T__ powTrend;
        (void) powTrend;  // dummy to suppress unused var warning

        stan::math::initialize(powTrend, DUMMY_VAR__);
        stan::math::fill(powTrend,DUMMY_VAR__);
        validate_non_negative_index("l", "N", N);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  l(static_cast<Eigen::VectorXd::Index>(N));
        (void) l;  // dummy to suppress unused var warning

        stan::math::initialize(l, DUMMY_VAR__);
        stan::math::fill(l,DUMMY_VAR__);
        validate_non_negative_index("b", "N", N);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  b(static_cast<Eigen::VectorXd::Index>(N));
        (void) b;  // dummy to suppress unused var warning

        stan::math::initialize(b, DUMMY_VAR__);
        stan::math::fill(b,DUMMY_VAR__);
        validate_non_negative_index("expVal", "N", N);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  expVal(static_cast<Eigen::VectorXd::Index>(N));
        (void) expVal;  // dummy to suppress unused var warning

        stan::math::initialize(expVal, DUMMY_VAR__);
        stan::math::fill(expVal,DUMMY_VAR__);
        validate_non_negative_index("smoothedInnovSize", "N", N);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  smoothedInnovSize(static_cast<Eigen::VectorXd::Index>(N));
        (void) smoothedInnovSize;  // dummy to suppress unused var warning

        stan::math::initialize(smoothedInnovSize, DUMMY_VAR__);
        stan::math::fill(smoothedInnovSize,DUMMY_VAR__);


        try {
            stan::math::assign(get_base1_lhs(smoothedInnovSize,1,"smoothedInnovSize",1), innovSizeInit);
            stan::math::assign(get_base1_lhs(l,1,"l",1), get_base1(y,1,"y",1));
            stan::math::assign(get_base1_lhs(b,1,"b",1), bInit);
            stan::math::assign(powTrend, (((MAX_POW_TREND - MIN_POW_TREND) * powTrendBeta) + MIN_POW_TREND));
            for (int t = 2; t <= N; ++t) {

                stan::math::assign(get_base1_lhs(expVal,t,"expVal",1), ((get_base1(l,(t - 1),"l",1) + (coefTrend * pow(fabs(get_base1(l,(t - 1),"l",1)),powTrend))) + (locTrendFract * get_base1(b,(t - 1),"b",1))));
                stan::math::assign(get_base1_lhs(smoothedInnovSize,t,"smoothedInnovSize",1), ((innovSm * fabs((get_base1(y,t,"y",1) - get_base1(expVal,t,"expVal",1)))) + ((1 - innovSm) * get_base1(smoothedInnovSize,(t - 1),"smoothedInnovSize",1))));
                stan::math::assign(get_base1_lhs(l,t,"l",1), ((levSm * get_base1(y,t,"y",1)) + ((1 - levSm) * get_base1(l,(t - 1),"l",1))));
                stan::math::assign(get_base1_lhs(b,t,"b",1), ((bSm * (get_base1(l,t,"l",1) - get_base1(l,(t - 1),"l",1))) + ((1 - bSm) * get_base1(b,(t - 1),"b",1))));
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        if (stan::math::is_uninitialized(powTrend)) {
            std::stringstream msg__;
            msg__ << "Undefined transformed parameter: powTrend";
            throw std::runtime_error(msg__.str());
        }
        for (int i0__ = 0; i0__ < N; ++i0__) {
            if (stan::math::is_uninitialized(l(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: l" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < N; ++i0__) {
            if (stan::math::is_uninitialized(b(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: b" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < N; ++i0__) {
            if (stan::math::is_uninitialized(expVal(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: expVal" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < N; ++i0__) {
            if (stan::math::is_uninitialized(smoothedInnovSize(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: smoothedInnovSize" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }

        const char* function__ = "validate transformed params";
        (void) function__;  // dummy to suppress unused var warning
        check_greater_or_equal(function__,"powTrend",powTrend,MIN_POW_TREND);
        check_less_or_equal(function__,"powTrend",powTrend,MAX_POW_TREND);

        // model body
        try {

            lp_accum__.add(cauchy_log<propto__>(sigma, 0, CAUCHY_SD));
            if (sigma < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-cauchy_ccdf_log(0, 0, CAUCHY_SD));
            lp_accum__.add(cauchy_log<propto__>(offsetSigma, MIN_SIGMA, CAUCHY_SD));
            if (offsetSigma < MIN_SIGMA) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-cauchy_ccdf_log(MIN_SIGMA, MIN_SIGMA, CAUCHY_SD));
            lp_accum__.add(cauchy_log<propto__>(coefTrend, 0, CAUCHY_SD));
            lp_accum__.add(beta_log<propto__>(powTrendBeta, POW_TREND_ALPHA, POW_TREND_BETA));
            lp_accum__.add(cauchy_log<propto__>(innovSizeInit, 0, CAUCHY_SD));
            if (innovSizeInit < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-cauchy_ccdf_log(0, 0, CAUCHY_SD));
            lp_accum__.add(normal_log<propto__>(bInit, 0, CAUCHY_SD));
            for (int t = 2; t <= N; ++t) {

                lp_accum__.add(student_t_log<propto__>(get_base1(y,t,"y",1), nu, get_base1(expVal,t,"expVal",1), ((sigma * get_base1(smoothedInnovSize,(t - 1),"smoothedInnovSize",1)) + offsetSigma)));
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("nu");
        names__.push_back("sigma");
        names__.push_back("levSm");
        names__.push_back("bSm");
        names__.push_back("bInit");
        names__.push_back("powTrendBeta");
        names__.push_back("coefTrend");
        names__.push_back("offsetSigma");
        names__.push_back("locTrendFract");
        names__.push_back("innovSm");
        names__.push_back("innovSizeInit");
        names__.push_back("powTrend");
        names__.push_back("l");
        names__.push_back("b");
        names__.push_back("expVal");
        names__.push_back("smoothedInnovSize");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_LGTe_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double nu = in__.scalar_lub_constrain(MIN_NU,MAX_NU);
        double sigma = in__.scalar_lb_constrain(0);
        double levSm = in__.scalar_lub_constrain(0,1);
        double bSm = in__.scalar_lub_constrain(0,1);
        double bInit = in__.scalar_constrain();
        double powTrendBeta = in__.scalar_lub_constrain(0,1);
        double coefTrend = in__.scalar_constrain();
        double offsetSigma = in__.scalar_lb_constrain(MIN_SIGMA);
        double locTrendFract = in__.scalar_lub_constrain(-(0.25),1);
        double innovSm = in__.scalar_lub_constrain(0,1);
        double innovSizeInit = in__.scalar_lb_constrain(0);
        vars__.push_back(nu);
        vars__.push_back(sigma);
        vars__.push_back(levSm);
        vars__.push_back(bSm);
        vars__.push_back(bInit);
        vars__.push_back(powTrendBeta);
        vars__.push_back(coefTrend);
        vars__.push_back(offsetSigma);
        vars__.push_back(locTrendFract);
        vars__.push_back(innovSm);
        vars__.push_back(innovSizeInit);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        double powTrend(0.0);
        (void) powTrend;  // dummy to suppress unused var warning

        stan::math::initialize(powTrend, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(powTrend,DUMMY_VAR__);
        validate_non_negative_index("l", "N", N);
        vector_d l(static_cast<Eigen::VectorXd::Index>(N));
        (void) l;  // dummy to suppress unused var warning

        stan::math::initialize(l, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(l,DUMMY_VAR__);
        validate_non_negative_index("b", "N", N);
        vector_d b(static_cast<Eigen::VectorXd::Index>(N));
        (void) b;  // dummy to suppress unused var warning

        stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b,DUMMY_VAR__);
        validate_non_negative_index("expVal", "N", N);
        vector_d expVal(static_cast<Eigen::VectorXd::Index>(N));
        (void) expVal;  // dummy to suppress unused var warning

        stan::math::initialize(expVal, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(expVal,DUMMY_VAR__);
        validate_non_negative_index("smoothedInnovSize", "N", N);
        vector_d smoothedInnovSize(static_cast<Eigen::VectorXd::Index>(N));
        (void) smoothedInnovSize;  // dummy to suppress unused var warning

        stan::math::initialize(smoothedInnovSize, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(smoothedInnovSize,DUMMY_VAR__);


        try {
            stan::math::assign(get_base1_lhs(smoothedInnovSize,1,"smoothedInnovSize",1), innovSizeInit);
            stan::math::assign(get_base1_lhs(l,1,"l",1), get_base1(y,1,"y",1));
            stan::math::assign(get_base1_lhs(b,1,"b",1), bInit);
            stan::math::assign(powTrend, (((MAX_POW_TREND - MIN_POW_TREND) * powTrendBeta) + MIN_POW_TREND));
            for (int t = 2; t <= N; ++t) {

                stan::math::assign(get_base1_lhs(expVal,t,"expVal",1), ((get_base1(l,(t - 1),"l",1) + (coefTrend * pow(fabs(get_base1(l,(t - 1),"l",1)),powTrend))) + (locTrendFract * get_base1(b,(t - 1),"b",1))));
                stan::math::assign(get_base1_lhs(smoothedInnovSize,t,"smoothedInnovSize",1), ((innovSm * fabs((get_base1(y,t,"y",1) - get_base1(expVal,t,"expVal",1)))) + ((1 - innovSm) * get_base1(smoothedInnovSize,(t - 1),"smoothedInnovSize",1))));
                stan::math::assign(get_base1_lhs(l,t,"l",1), ((levSm * get_base1(y,t,"y",1)) + ((1 - levSm) * get_base1(l,(t - 1),"l",1))));
                stan::math::assign(get_base1_lhs(b,t,"b",1), ((bSm * (get_base1(l,t,"l",1) - get_base1(l,(t - 1),"l",1))) + ((1 - bSm) * get_base1(b,(t - 1),"b",1))));
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        check_greater_or_equal(function__,"powTrend",powTrend,MIN_POW_TREND);
        check_less_or_equal(function__,"powTrend",powTrend,MAX_POW_TREND);

        // write transformed parameters
        vars__.push_back(powTrend);
        for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(l[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(expVal[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(smoothedInnovSize[k_0__]);
        }

        if (!include_gqs__) return;
        // declare and define generated quantities


        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate generated quantities

        // write generated quantities
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_LGTe";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "nu";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "levSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "bSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "bInit";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrendBeta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "coefTrend";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "offsetSigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "locTrendFract";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "innovSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "innovSizeInit";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrend";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "l" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "expVal" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "smoothedInnovSize" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "nu";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "levSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "bSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "bInit";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrendBeta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "coefTrend";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "offsetSigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "locTrendFract";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "innovSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "innovSizeInit";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrend";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "l" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "expVal" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "smoothedInnovSize" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
    }

}; // model

}




// Code generated by Stan version 2.16.0

#include <stan/model/model_header.hpp>

namespace model_SGTe_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_SGTe");
    reader.add_event(70, 70, "end", "model_SGTe");
    return reader;
}

class model_SGTe : public prob_grad {
private:
    int SEASONALITY;
    double CAUCHY_SD;
    double MIN_POW_TREND;
    double MAX_POW_TREND;
    double MIN_SIGMA;
    double MIN_NU;
    double MAX_NU;
    int N;
    vector_d y;
    double POW_TREND_ALPHA;
    double POW_TREND_BETA;
public:
    model_SGTe(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_SGTe(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_SGTe_namespace::model_SGTe";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        context__.validate_dims("data initialization", "SEASONALITY", "int", context__.to_vec());
        SEASONALITY = int(0);
        vals_i__ = context__.vals_i("SEASONALITY");
        pos__ = 0;
        SEASONALITY = vals_i__[pos__++];
        context__.validate_dims("data initialization", "CAUCHY_SD", "double", context__.to_vec());
        CAUCHY_SD = double(0);
        vals_r__ = context__.vals_r("CAUCHY_SD");
        pos__ = 0;
        CAUCHY_SD = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MIN_POW_TREND", "double", context__.to_vec());
        MIN_POW_TREND = double(0);
        vals_r__ = context__.vals_r("MIN_POW_TREND");
        pos__ = 0;
        MIN_POW_TREND = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MAX_POW_TREND", "double", context__.to_vec());
        MAX_POW_TREND = double(0);
        vals_r__ = context__.vals_r("MAX_POW_TREND");
        pos__ = 0;
        MAX_POW_TREND = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MIN_SIGMA", "double", context__.to_vec());
        MIN_SIGMA = double(0);
        vals_r__ = context__.vals_r("MIN_SIGMA");
        pos__ = 0;
        MIN_SIGMA = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MIN_NU", "double", context__.to_vec());
        MIN_NU = double(0);
        vals_r__ = context__.vals_r("MIN_NU");
        pos__ = 0;
        MIN_NU = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MAX_NU", "double", context__.to_vec());
        MAX_NU = double(0);
        vals_r__ = context__.vals_r("MAX_NU");
        pos__ = 0;
        MAX_NU = vals_r__[pos__++];
        context__.validate_dims("data initialization", "N", "int", context__.to_vec());
        N = int(0);
        vals_i__ = context__.vals_i("N");
        pos__ = 0;
        N = vals_i__[pos__++];
        validate_non_negative_index("y", "N", N);
        context__.validate_dims("data initialization", "y", "vector_d", context__.to_vec(N));
        validate_non_negative_index("y", "N", N);
        y = vector_d(static_cast<Eigen::VectorXd::Index>(N));
        vals_r__ = context__.vals_r("y");
        pos__ = 0;
        size_t y_i_vec_lim__ = N;
        for (size_t i_vec__ = 0; i_vec__ < y_i_vec_lim__; ++i_vec__) {
            y[i_vec__] = vals_r__[pos__++];
        }
        context__.validate_dims("data initialization", "POW_TREND_ALPHA", "double", context__.to_vec());
        POW_TREND_ALPHA = double(0);
        vals_r__ = context__.vals_r("POW_TREND_ALPHA");
        pos__ = 0;
        POW_TREND_ALPHA = vals_r__[pos__++];
        context__.validate_dims("data initialization", "POW_TREND_BETA", "double", context__.to_vec());
        POW_TREND_BETA = double(0);
        vals_r__ = context__.vals_r("POW_TREND_BETA");
        pos__ = 0;
        POW_TREND_BETA = vals_r__[pos__++];

        // validate, data variables
        check_greater_or_equal(function__,"SEASONALITY",SEASONALITY,2);
        check_greater_or_equal(function__,"CAUCHY_SD",CAUCHY_SD,0);
        check_greater_or_equal(function__,"MIN_SIGMA",MIN_SIGMA,0);
        check_greater_or_equal(function__,"MIN_NU",MIN_NU,1);
        check_greater_or_equal(function__,"MAX_NU",MAX_NU,1);
        check_greater_or_equal(function__,"N",N,1);
        check_greater_or_equal(function__,"y",y,0);
        check_greater_or_equal(function__,"POW_TREND_ALPHA",POW_TREND_ALPHA,0);
        check_greater_or_equal(function__,"POW_TREND_BETA",POW_TREND_BETA,0);
        // initialize data variables

        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed data

        // validate, set parameter ranges
        num_params_r__ = 0U;
        param_ranges_i__.clear();
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        validate_non_negative_index("initSu", "SEASONALITY", SEASONALITY);
        num_params_r__ += SEASONALITY;
    }

    ~model_SGTe() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("nu")))
            throw std::runtime_error("variable nu missing");
        vals_r__ = context__.vals_r("nu");
        pos__ = 0U;
        context__.validate_dims("initialization", "nu", "double", context__.to_vec());
        // generate_declaration nu
        double nu(0);
        nu = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(MIN_NU,MAX_NU,nu);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable nu: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma", "double", context__.to_vec());
        // generate_declaration sigma
        double sigma(0);
        sigma = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("levSm")))
            throw std::runtime_error("variable levSm missing");
        vals_r__ = context__.vals_r("levSm");
        pos__ = 0U;
        context__.validate_dims("initialization", "levSm", "double", context__.to_vec());
        // generate_declaration levSm
        double levSm(0);
        levSm = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,levSm);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable levSm: ") + e.what());
        }

        if (!(context__.contains_r("sSm")))
            throw std::runtime_error("variable sSm missing");
        vals_r__ = context__.vals_r("sSm");
        pos__ = 0U;
        context__.validate_dims("initialization", "sSm", "double", context__.to_vec());
        // generate_declaration sSm
        double sSm(0);
        sSm = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,sSm);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sSm: ") + e.what());
        }

        if (!(context__.contains_r("powTrendBeta")))
            throw std::runtime_error("variable powTrendBeta missing");
        vals_r__ = context__.vals_r("powTrendBeta");
        pos__ = 0U;
        context__.validate_dims("initialization", "powTrendBeta", "double", context__.to_vec());
        // generate_declaration powTrendBeta
        double powTrendBeta(0);
        powTrendBeta = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,powTrendBeta);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable powTrendBeta: ") + e.what());
        }

        if (!(context__.contains_r("coefTrend")))
            throw std::runtime_error("variable coefTrend missing");
        vals_r__ = context__.vals_r("coefTrend");
        pos__ = 0U;
        context__.validate_dims("initialization", "coefTrend", "double", context__.to_vec());
        // generate_declaration coefTrend
        double coefTrend(0);
        coefTrend = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(coefTrend);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable coefTrend: ") + e.what());
        }

        if (!(context__.contains_r("offsetSigma")))
            throw std::runtime_error("variable offsetSigma missing");
        vals_r__ = context__.vals_r("offsetSigma");
        pos__ = 0U;
        context__.validate_dims("initialization", "offsetSigma", "double", context__.to_vec());
        // generate_declaration offsetSigma
        double offsetSigma(0);
        offsetSigma = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(MIN_SIGMA,offsetSigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable offsetSigma: ") + e.what());
        }

        if (!(context__.contains_r("innovSm")))
            throw std::runtime_error("variable innovSm missing");
        vals_r__ = context__.vals_r("innovSm");
        pos__ = 0U;
        context__.validate_dims("initialization", "innovSm", "double", context__.to_vec());
        // generate_declaration innovSm
        double innovSm(0);
        innovSm = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,innovSm);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable innovSm: ") + e.what());
        }

        if (!(context__.contains_r("innovSizeInit")))
            throw std::runtime_error("variable innovSizeInit missing");
        vals_r__ = context__.vals_r("innovSizeInit");
        pos__ = 0U;
        context__.validate_dims("initialization", "innovSizeInit", "double", context__.to_vec());
        // generate_declaration innovSizeInit
        double innovSizeInit(0);
        innovSizeInit = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,innovSizeInit);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable innovSizeInit: ") + e.what());
        }

        if (!(context__.contains_r("initSu")))
            throw std::runtime_error("variable initSu missing");
        vals_r__ = context__.vals_r("initSu");
        pos__ = 0U;
        validate_non_negative_index("initSu", "SEASONALITY", SEASONALITY);
        context__.validate_dims("initialization", "initSu", "vector_d", context__.to_vec(SEASONALITY));
        // generate_declaration initSu
        vector_d initSu(static_cast<Eigen::VectorXd::Index>(SEASONALITY));
        for (int j1__ = 0U; j1__ < SEASONALITY; ++j1__)
            initSu(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(initSu);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable initSu: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        // model parameters
        stan::io::reader<T__> in__(params_r__,params_i__);

        T__ nu;
        (void) nu;  // dummy to suppress unused var warning
        if (jacobian__)
            nu = in__.scalar_lub_constrain(MIN_NU,MAX_NU,lp__);
        else
            nu = in__.scalar_lub_constrain(MIN_NU,MAX_NU);

        T__ sigma;
        (void) sigma;  // dummy to suppress unused var warning
        if (jacobian__)
            sigma = in__.scalar_lb_constrain(0,lp__);
        else
            sigma = in__.scalar_lb_constrain(0);

        T__ levSm;
        (void) levSm;  // dummy to suppress unused var warning
        if (jacobian__)
            levSm = in__.scalar_lub_constrain(0,1,lp__);
        else
            levSm = in__.scalar_lub_constrain(0,1);

        T__ sSm;
        (void) sSm;  // dummy to suppress unused var warning
        if (jacobian__)
            sSm = in__.scalar_lub_constrain(0,1,lp__);
        else
            sSm = in__.scalar_lub_constrain(0,1);

        T__ powTrendBeta;
        (void) powTrendBeta;  // dummy to suppress unused var warning
        if (jacobian__)
            powTrendBeta = in__.scalar_lub_constrain(0,1,lp__);
        else
            powTrendBeta = in__.scalar_lub_constrain(0,1);

        T__ coefTrend;
        (void) coefTrend;  // dummy to suppress unused var warning
        if (jacobian__)
            coefTrend = in__.scalar_constrain(lp__);
        else
            coefTrend = in__.scalar_constrain();

        T__ offsetSigma;
        (void) offsetSigma;  // dummy to suppress unused var warning
        if (jacobian__)
            offsetSigma = in__.scalar_lb_constrain(MIN_SIGMA,lp__);
        else
            offsetSigma = in__.scalar_lb_constrain(MIN_SIGMA);

        T__ innovSm;
        (void) innovSm;  // dummy to suppress unused var warning
        if (jacobian__)
            innovSm = in__.scalar_lub_constrain(0,1,lp__);
        else
            innovSm = in__.scalar_lub_constrain(0,1);

        T__ innovSizeInit;
        (void) innovSizeInit;  // dummy to suppress unused var warning
        if (jacobian__)
            innovSizeInit = in__.scalar_lb_constrain(0,lp__);
        else
            innovSizeInit = in__.scalar_lb_constrain(0);

        Eigen::Matrix<T__,Eigen::Dynamic,1>  initSu;
        (void) initSu;  // dummy to suppress unused var warning
        if (jacobian__)
            initSu = in__.vector_constrain(SEASONALITY,lp__);
        else
            initSu = in__.vector_constrain(SEASONALITY);


        // transformed parameters
        T__ powTrend;
        (void) powTrend;  // dummy to suppress unused var warning

        stan::math::initialize(powTrend, DUMMY_VAR__);
        stan::math::fill(powTrend,DUMMY_VAR__);
        validate_non_negative_index("l", "N", N);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  l(static_cast<Eigen::VectorXd::Index>(N));
        (void) l;  // dummy to suppress unused var warning

        stan::math::initialize(l, DUMMY_VAR__);
        stan::math::fill(l,DUMMY_VAR__);
        validate_non_negative_index("expVal", "N", N);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  expVal(static_cast<Eigen::VectorXd::Index>(N));
        (void) expVal;  // dummy to suppress unused var warning

        stan::math::initialize(expVal, DUMMY_VAR__);
        stan::math::fill(expVal,DUMMY_VAR__);
        validate_non_negative_index("smoothedInnovSize", "N", N);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  smoothedInnovSize(static_cast<Eigen::VectorXd::Index>(N));
        (void) smoothedInnovSize;  // dummy to suppress unused var warning

        stan::math::initialize(smoothedInnovSize, DUMMY_VAR__);
        stan::math::fill(smoothedInnovSize,DUMMY_VAR__);
        validate_non_negative_index("inits", "SEASONALITY", SEASONALITY);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  inits(static_cast<Eigen::VectorXd::Index>(SEASONALITY));
        (void) inits;  // dummy to suppress unused var warning

        stan::math::initialize(inits, DUMMY_VAR__);
        stan::math::fill(inits,DUMMY_VAR__);
        validate_non_negative_index("s", "(N + SEASONALITY)", (N + SEASONALITY));
        Eigen::Matrix<T__,Eigen::Dynamic,1>  s(static_cast<Eigen::VectorXd::Index>((N + SEASONALITY)));
        (void) s;  // dummy to suppress unused var warning

        stan::math::initialize(s, DUMMY_VAR__);
        stan::math::fill(s,DUMMY_VAR__);
        T__ sumsu;
        (void) sumsu;  // dummy to suppress unused var warning

        stan::math::initialize(sumsu, DUMMY_VAR__);
        stan::math::fill(sumsu,DUMMY_VAR__);


        try {
            stan::math::assign(get_base1_lhs(smoothedInnovSize,1,"smoothedInnovSize",1), innovSizeInit);
            stan::math::assign(sumsu, 0);
            for (int i = 1; i <= SEASONALITY; ++i) {
                stan::math::assign(sumsu, (sumsu + get_base1(initSu,i,"initSu",1)));
            }
            for (int i = 1; i <= SEASONALITY; ++i) {
                stan::math::assign(get_base1_lhs(inits,i,"inits",1), ((get_base1(initSu,i,"initSu",1) * SEASONALITY) / sumsu));
            }
            for (int i = 1; i <= SEASONALITY; ++i) {

                stan::math::assign(get_base1_lhs(s,i,"s",1), get_base1(inits,i,"inits",1));
            }
            stan::math::assign(get_base1_lhs(s,(SEASONALITY + 1),"s",1), get_base1(inits,1,"inits",1));
            stan::math::assign(get_base1_lhs(l,1,"l",1), (get_base1(y,1,"y",1) / get_base1(s,1,"s",1)));
            stan::math::assign(powTrend, (((MAX_POW_TREND - MIN_POW_TREND) * powTrendBeta) + MIN_POW_TREND));
            for (int t = 2; t <= N; ++t) {

                stan::math::assign(get_base1_lhs(expVal,t,"expVal",1), ((get_base1(l,(t - 1),"l",1) + (coefTrend * pow(fabs(get_base1(l,(t - 1),"l",1)),powTrend))) * get_base1(s,t,"s",1)));
                stan::math::assign(get_base1_lhs(smoothedInnovSize,t,"smoothedInnovSize",1), (((innovSm * fabs((get_base1(y,t,"y",1) - get_base1(expVal,t,"expVal",1)))) / get_base1(s,t,"s",1)) + ((1 - innovSm) * get_base1(smoothedInnovSize,(t - 1),"smoothedInnovSize",1))));
                stan::math::assign(get_base1_lhs(l,t,"l",1), (((levSm * get_base1(y,t,"y",1)) / get_base1(s,t,"s",1)) + ((1 - levSm) * get_base1(l,(t - 1),"l",1))));
                stan::math::assign(get_base1_lhs(s,(t + SEASONALITY),"s",1), (((sSm * get_base1(y,t,"y",1)) / get_base1(l,t,"l",1)) + ((1 - sSm) * get_base1(s,t,"s",1))));
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        if (stan::math::is_uninitialized(powTrend)) {
            std::stringstream msg__;
            msg__ << "Undefined transformed parameter: powTrend";
            throw std::runtime_error(msg__.str());
        }
        for (int i0__ = 0; i0__ < N; ++i0__) {
            if (stan::math::is_uninitialized(l(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: l" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < N; ++i0__) {
            if (stan::math::is_uninitialized(expVal(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: expVal" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < N; ++i0__) {
            if (stan::math::is_uninitialized(smoothedInnovSize(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: smoothedInnovSize" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < SEASONALITY; ++i0__) {
            if (stan::math::is_uninitialized(inits(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: inits" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < (N + SEASONALITY); ++i0__) {
            if (stan::math::is_uninitialized(s(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: s" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        if (stan::math::is_uninitialized(sumsu)) {
            std::stringstream msg__;
            msg__ << "Undefined transformed parameter: sumsu";
            throw std::runtime_error(msg__.str());
        }

        const char* function__ = "validate transformed params";
        (void) function__;  // dummy to suppress unused var warning
        check_greater_or_equal(function__,"powTrend",powTrend,MIN_POW_TREND);
        check_less_or_equal(function__,"powTrend",powTrend,MAX_POW_TREND);

        // model body
        try {

            lp_accum__.add(cauchy_log<propto__>(sigma, 0, CAUCHY_SD));
            if (sigma < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-cauchy_ccdf_log(0, 0, CAUCHY_SD));
            lp_accum__.add(cauchy_log<propto__>(offsetSigma, MIN_SIGMA, CAUCHY_SD));
            if (offsetSigma < MIN_SIGMA) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-cauchy_ccdf_log(MIN_SIGMA, MIN_SIGMA, CAUCHY_SD));
            lp_accum__.add(cauchy_log<propto__>(coefTrend, 0, CAUCHY_SD));
            lp_accum__.add(beta_log<propto__>(powTrendBeta, POW_TREND_ALPHA, POW_TREND_BETA));
            lp_accum__.add(normal_log<propto__>(innovSizeInit, 0, CAUCHY_SD));
            if (innovSizeInit < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-normal_ccdf_log(0, 0, CAUCHY_SD));
            for (int t = 1; t <= SEASONALITY; ++t) {

                lp_accum__.add(normal_log<propto__>(get_base1(initSu,t,"initSu",1), 1, 0.29999999999999999));
                if (get_base1(initSu,t,"initSu",1) < 0.01) lp_accum__.add(-std::numeric_limits<double>::infinity());
                else lp_accum__.add(-normal_ccdf_log(0.01, 1, 0.29999999999999999));
            }
            for (int t = 2; t <= N; ++t) {

                lp_accum__.add(student_t_log<propto__>(get_base1(y,t,"y",1), nu, get_base1(expVal,t,"expVal",1), ((sigma * get_base1(smoothedInnovSize,(t - 1),"smoothedInnovSize",1)) + offsetSigma)));
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("nu");
        names__.push_back("sigma");
        names__.push_back("levSm");
        names__.push_back("sSm");
        names__.push_back("powTrendBeta");
        names__.push_back("coefTrend");
        names__.push_back("offsetSigma");
        names__.push_back("innovSm");
        names__.push_back("innovSizeInit");
        names__.push_back("initSu");
        names__.push_back("powTrend");
        names__.push_back("l");
        names__.push_back("expVal");
        names__.push_back("smoothedInnovSize");
        names__.push_back("inits");
        names__.push_back("s");
        names__.push_back("sumsu");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(SEASONALITY);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(SEASONALITY);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((N + SEASONALITY));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_SGTe_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double nu = in__.scalar_lub_constrain(MIN_NU,MAX_NU);
        double sigma = in__.scalar_lb_constrain(0);
        double levSm = in__.scalar_lub_constrain(0,1);
        double sSm = in__.scalar_lub_constrain(0,1);
        double powTrendBeta = in__.scalar_lub_constrain(0,1);
        double coefTrend = in__.scalar_constrain();
        double offsetSigma = in__.scalar_lb_constrain(MIN_SIGMA);
        double innovSm = in__.scalar_lub_constrain(0,1);
        double innovSizeInit = in__.scalar_lb_constrain(0);
        vector_d initSu = in__.vector_constrain(SEASONALITY);
        vars__.push_back(nu);
        vars__.push_back(sigma);
        vars__.push_back(levSm);
        vars__.push_back(sSm);
        vars__.push_back(powTrendBeta);
        vars__.push_back(coefTrend);
        vars__.push_back(offsetSigma);
        vars__.push_back(innovSm);
        vars__.push_back(innovSizeInit);
        for (int k_0__ = 0; k_0__ < SEASONALITY; ++k_0__) {
            vars__.push_back(initSu[k_0__]);
        }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        double powTrend(0.0);
        (void) powTrend;  // dummy to suppress unused var warning

        stan::math::initialize(powTrend, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(powTrend,DUMMY_VAR__);
        validate_non_negative_index("l", "N", N);
        vector_d l(static_cast<Eigen::VectorXd::Index>(N));
        (void) l;  // dummy to suppress unused var warning

        stan::math::initialize(l, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(l,DUMMY_VAR__);
        validate_non_negative_index("expVal", "N", N);
        vector_d expVal(static_cast<Eigen::VectorXd::Index>(N));
        (void) expVal;  // dummy to suppress unused var warning

        stan::math::initialize(expVal, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(expVal,DUMMY_VAR__);
        validate_non_negative_index("smoothedInnovSize", "N", N);
        vector_d smoothedInnovSize(static_cast<Eigen::VectorXd::Index>(N));
        (void) smoothedInnovSize;  // dummy to suppress unused var warning

        stan::math::initialize(smoothedInnovSize, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(smoothedInnovSize,DUMMY_VAR__);
        validate_non_negative_index("inits", "SEASONALITY", SEASONALITY);
        vector_d inits(static_cast<Eigen::VectorXd::Index>(SEASONALITY));
        (void) inits;  // dummy to suppress unused var warning

        stan::math::initialize(inits, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(inits,DUMMY_VAR__);
        validate_non_negative_index("s", "(N + SEASONALITY)", (N + SEASONALITY));
        vector_d s(static_cast<Eigen::VectorXd::Index>((N + SEASONALITY)));
        (void) s;  // dummy to suppress unused var warning

        stan::math::initialize(s, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(s,DUMMY_VAR__);
        double sumsu(0.0);
        (void) sumsu;  // dummy to suppress unused var warning

        stan::math::initialize(sumsu, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(sumsu,DUMMY_VAR__);


        try {
            stan::math::assign(get_base1_lhs(smoothedInnovSize,1,"smoothedInnovSize",1), innovSizeInit);
            stan::math::assign(sumsu, 0);
            for (int i = 1; i <= SEASONALITY; ++i) {
                stan::math::assign(sumsu, (sumsu + get_base1(initSu,i,"initSu",1)));
            }
            for (int i = 1; i <= SEASONALITY; ++i) {
                stan::math::assign(get_base1_lhs(inits,i,"inits",1), ((get_base1(initSu,i,"initSu",1) * SEASONALITY) / sumsu));
            }
            for (int i = 1; i <= SEASONALITY; ++i) {

                stan::math::assign(get_base1_lhs(s,i,"s",1), get_base1(inits,i,"inits",1));
            }
            stan::math::assign(get_base1_lhs(s,(SEASONALITY + 1),"s",1), get_base1(inits,1,"inits",1));
            stan::math::assign(get_base1_lhs(l,1,"l",1), (get_base1(y,1,"y",1) / get_base1(s,1,"s",1)));
            stan::math::assign(powTrend, (((MAX_POW_TREND - MIN_POW_TREND) * powTrendBeta) + MIN_POW_TREND));
            for (int t = 2; t <= N; ++t) {

                stan::math::assign(get_base1_lhs(expVal,t,"expVal",1), ((get_base1(l,(t - 1),"l",1) + (coefTrend * pow(fabs(get_base1(l,(t - 1),"l",1)),powTrend))) * get_base1(s,t,"s",1)));
                stan::math::assign(get_base1_lhs(smoothedInnovSize,t,"smoothedInnovSize",1), (((innovSm * fabs((get_base1(y,t,"y",1) - get_base1(expVal,t,"expVal",1)))) / get_base1(s,t,"s",1)) + ((1 - innovSm) * get_base1(smoothedInnovSize,(t - 1),"smoothedInnovSize",1))));
                stan::math::assign(get_base1_lhs(l,t,"l",1), (((levSm * get_base1(y,t,"y",1)) / get_base1(s,t,"s",1)) + ((1 - levSm) * get_base1(l,(t - 1),"l",1))));
                stan::math::assign(get_base1_lhs(s,(t + SEASONALITY),"s",1), (((sSm * get_base1(y,t,"y",1)) / get_base1(l,t,"l",1)) + ((1 - sSm) * get_base1(s,t,"s",1))));
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        check_greater_or_equal(function__,"powTrend",powTrend,MIN_POW_TREND);
        check_less_or_equal(function__,"powTrend",powTrend,MAX_POW_TREND);

        // write transformed parameters
        vars__.push_back(powTrend);
        for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(l[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(expVal[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(smoothedInnovSize[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < SEASONALITY; ++k_0__) {
            vars__.push_back(inits[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < (N + SEASONALITY); ++k_0__) {
            vars__.push_back(s[k_0__]);
        }
        vars__.push_back(sumsu);

        if (!include_gqs__) return;
        // declare and define generated quantities


        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate generated quantities

        // write generated quantities
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_SGTe";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "nu";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "levSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrendBeta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "coefTrend";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "offsetSigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "innovSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "innovSizeInit";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= SEASONALITY; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "initSu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrend";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "l" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "expVal" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "smoothedInnovSize" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= SEASONALITY; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "inits" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= (N + SEASONALITY); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "s" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sumsu";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "nu";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "levSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrendBeta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "coefTrend";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "offsetSigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "innovSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "innovSizeInit";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= SEASONALITY; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "initSu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrend";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "l" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "expVal" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "smoothedInnovSize" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= SEASONALITY; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "inits" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= (N + SEASONALITY); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "s" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sumsu";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
    }

}; // model

}




// Code generated by Stan version 2.16.0

#include <stan/model/model_header.hpp>

namespace model_lgt_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_lgt");
    reader.add_event(49, 49, "end", "model_lgt");
    return reader;
}

class model_lgt : public prob_grad {
private:
    double CAUCHY_SD;
    double MIN_POW_TREND;
    double MAX_POW_TREND;
    double MIN_SIGMA;
    double MIN_NU;
    double MAX_NU;
    int N;
    vector_d y;
    double POW_TREND_ALPHA;
    double POW_TREND_BETA;
    double POW_SIGMA_ALPHA;
    double POW_SIGMA_BETA;
public:
    model_lgt(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_lgt(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_lgt_namespace::model_lgt";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        context__.validate_dims("data initialization", "CAUCHY_SD", "double", context__.to_vec());
        CAUCHY_SD = double(0);
        vals_r__ = context__.vals_r("CAUCHY_SD");
        pos__ = 0;
        CAUCHY_SD = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MIN_POW_TREND", "double", context__.to_vec());
        MIN_POW_TREND = double(0);
        vals_r__ = context__.vals_r("MIN_POW_TREND");
        pos__ = 0;
        MIN_POW_TREND = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MAX_POW_TREND", "double", context__.to_vec());
        MAX_POW_TREND = double(0);
        vals_r__ = context__.vals_r("MAX_POW_TREND");
        pos__ = 0;
        MAX_POW_TREND = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MIN_SIGMA", "double", context__.to_vec());
        MIN_SIGMA = double(0);
        vals_r__ = context__.vals_r("MIN_SIGMA");
        pos__ = 0;
        MIN_SIGMA = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MIN_NU", "double", context__.to_vec());
        MIN_NU = double(0);
        vals_r__ = context__.vals_r("MIN_NU");
        pos__ = 0;
        MIN_NU = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MAX_NU", "double", context__.to_vec());
        MAX_NU = double(0);
        vals_r__ = context__.vals_r("MAX_NU");
        pos__ = 0;
        MAX_NU = vals_r__[pos__++];
        context__.validate_dims("data initialization", "N", "int", context__.to_vec());
        N = int(0);
        vals_i__ = context__.vals_i("N");
        pos__ = 0;
        N = vals_i__[pos__++];
        validate_non_negative_index("y", "N", N);
        context__.validate_dims("data initialization", "y", "vector_d", context__.to_vec(N));
        validate_non_negative_index("y", "N", N);
        y = vector_d(static_cast<Eigen::VectorXd::Index>(N));
        vals_r__ = context__.vals_r("y");
        pos__ = 0;
        size_t y_i_vec_lim__ = N;
        for (size_t i_vec__ = 0; i_vec__ < y_i_vec_lim__; ++i_vec__) {
            y[i_vec__] = vals_r__[pos__++];
        }
        context__.validate_dims("data initialization", "POW_TREND_ALPHA", "double", context__.to_vec());
        POW_TREND_ALPHA = double(0);
        vals_r__ = context__.vals_r("POW_TREND_ALPHA");
        pos__ = 0;
        POW_TREND_ALPHA = vals_r__[pos__++];
        context__.validate_dims("data initialization", "POW_TREND_BETA", "double", context__.to_vec());
        POW_TREND_BETA = double(0);
        vals_r__ = context__.vals_r("POW_TREND_BETA");
        pos__ = 0;
        POW_TREND_BETA = vals_r__[pos__++];
        context__.validate_dims("data initialization", "POW_SIGMA_ALPHA", "double", context__.to_vec());
        POW_SIGMA_ALPHA = double(0);
        vals_r__ = context__.vals_r("POW_SIGMA_ALPHA");
        pos__ = 0;
        POW_SIGMA_ALPHA = vals_r__[pos__++];
        context__.validate_dims("data initialization", "POW_SIGMA_BETA", "double", context__.to_vec());
        POW_SIGMA_BETA = double(0);
        vals_r__ = context__.vals_r("POW_SIGMA_BETA");
        pos__ = 0;
        POW_SIGMA_BETA = vals_r__[pos__++];

        // validate, data variables
        check_greater_or_equal(function__,"CAUCHY_SD",CAUCHY_SD,0);
        check_greater_or_equal(function__,"MIN_SIGMA",MIN_SIGMA,0);
        check_greater_or_equal(function__,"MIN_NU",MIN_NU,1);
        check_greater_or_equal(function__,"MAX_NU",MAX_NU,1);
        check_greater_or_equal(function__,"N",N,1);
        check_greater_or_equal(function__,"y",y,0);
        check_greater_or_equal(function__,"POW_TREND_ALPHA",POW_TREND_ALPHA,0);
        check_greater_or_equal(function__,"POW_TREND_BETA",POW_TREND_BETA,0);
        check_greater_or_equal(function__,"POW_SIGMA_ALPHA",POW_SIGMA_ALPHA,0);
        check_greater_or_equal(function__,"POW_SIGMA_BETA",POW_SIGMA_BETA,0);
        // initialize data variables

        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed data

        // validate, set parameter ranges
        num_params_r__ = 0U;
        param_ranges_i__.clear();
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
    }

    ~model_lgt() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("nu")))
            throw std::runtime_error("variable nu missing");
        vals_r__ = context__.vals_r("nu");
        pos__ = 0U;
        context__.validate_dims("initialization", "nu", "double", context__.to_vec());
        // generate_declaration nu
        double nu(0);
        nu = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(MIN_NU,MAX_NU,nu);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable nu: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma", "double", context__.to_vec());
        // generate_declaration sigma
        double sigma(0);
        sigma = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("levSm")))
            throw std::runtime_error("variable levSm missing");
        vals_r__ = context__.vals_r("levSm");
        pos__ = 0U;
        context__.validate_dims("initialization", "levSm", "double", context__.to_vec());
        // generate_declaration levSm
        double levSm(0);
        levSm = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,levSm);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable levSm: ") + e.what());
        }

        if (!(context__.contains_r("bSm")))
            throw std::runtime_error("variable bSm missing");
        vals_r__ = context__.vals_r("bSm");
        pos__ = 0U;
        context__.validate_dims("initialization", "bSm", "double", context__.to_vec());
        // generate_declaration bSm
        double bSm(0);
        bSm = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,bSm);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable bSm: ") + e.what());
        }

        if (!(context__.contains_r("powx")))
            throw std::runtime_error("variable powx missing");
        vals_r__ = context__.vals_r("powx");
        pos__ = 0U;
        context__.validate_dims("initialization", "powx", "double", context__.to_vec());
        // generate_declaration powx
        double powx(0);
        powx = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,powx);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable powx: ") + e.what());
        }

        if (!(context__.contains_r("bInit")))
            throw std::runtime_error("variable bInit missing");
        vals_r__ = context__.vals_r("bInit");
        pos__ = 0U;
        context__.validate_dims("initialization", "bInit", "double", context__.to_vec());
        // generate_declaration bInit
        double bInit(0);
        bInit = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(bInit);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable bInit: ") + e.what());
        }

        if (!(context__.contains_r("powTrendBeta")))
            throw std::runtime_error("variable powTrendBeta missing");
        vals_r__ = context__.vals_r("powTrendBeta");
        pos__ = 0U;
        context__.validate_dims("initialization", "powTrendBeta", "double", context__.to_vec());
        // generate_declaration powTrendBeta
        double powTrendBeta(0);
        powTrendBeta = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,powTrendBeta);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable powTrendBeta: ") + e.what());
        }

        if (!(context__.contains_r("coefTrend")))
            throw std::runtime_error("variable coefTrend missing");
        vals_r__ = context__.vals_r("coefTrend");
        pos__ = 0U;
        context__.validate_dims("initialization", "coefTrend", "double", context__.to_vec());
        // generate_declaration coefTrend
        double coefTrend(0);
        coefTrend = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(coefTrend);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable coefTrend: ") + e.what());
        }

        if (!(context__.contains_r("offsetSigma")))
            throw std::runtime_error("variable offsetSigma missing");
        vals_r__ = context__.vals_r("offsetSigma");
        pos__ = 0U;
        context__.validate_dims("initialization", "offsetSigma", "double", context__.to_vec());
        // generate_declaration offsetSigma
        double offsetSigma(0);
        offsetSigma = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(MIN_SIGMA,offsetSigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable offsetSigma: ") + e.what());
        }

        if (!(context__.contains_r("locTrendFract")))
            throw std::runtime_error("variable locTrendFract missing");
        vals_r__ = context__.vals_r("locTrendFract");
        pos__ = 0U;
        context__.validate_dims("initialization", "locTrendFract", "double", context__.to_vec());
        // generate_declaration locTrendFract
        double locTrendFract(0);
        locTrendFract = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(-(0.25),1,locTrendFract);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable locTrendFract: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        // model parameters
        stan::io::reader<T__> in__(params_r__,params_i__);

        T__ nu;
        (void) nu;  // dummy to suppress unused var warning
        if (jacobian__)
            nu = in__.scalar_lub_constrain(MIN_NU,MAX_NU,lp__);
        else
            nu = in__.scalar_lub_constrain(MIN_NU,MAX_NU);

        T__ sigma;
        (void) sigma;  // dummy to suppress unused var warning
        if (jacobian__)
            sigma = in__.scalar_lb_constrain(0,lp__);
        else
            sigma = in__.scalar_lb_constrain(0);

        T__ levSm;
        (void) levSm;  // dummy to suppress unused var warning
        if (jacobian__)
            levSm = in__.scalar_lub_constrain(0,1,lp__);
        else
            levSm = in__.scalar_lub_constrain(0,1);

        T__ bSm;
        (void) bSm;  // dummy to suppress unused var warning
        if (jacobian__)
            bSm = in__.scalar_lub_constrain(0,1,lp__);
        else
            bSm = in__.scalar_lub_constrain(0,1);

        T__ powx;
        (void) powx;  // dummy to suppress unused var warning
        if (jacobian__)
            powx = in__.scalar_lub_constrain(0,1,lp__);
        else
            powx = in__.scalar_lub_constrain(0,1);

        T__ bInit;
        (void) bInit;  // dummy to suppress unused var warning
        if (jacobian__)
            bInit = in__.scalar_constrain(lp__);
        else
            bInit = in__.scalar_constrain();

        T__ powTrendBeta;
        (void) powTrendBeta;  // dummy to suppress unused var warning
        if (jacobian__)
            powTrendBeta = in__.scalar_lub_constrain(0,1,lp__);
        else
            powTrendBeta = in__.scalar_lub_constrain(0,1);

        T__ coefTrend;
        (void) coefTrend;  // dummy to suppress unused var warning
        if (jacobian__)
            coefTrend = in__.scalar_constrain(lp__);
        else
            coefTrend = in__.scalar_constrain();

        T__ offsetSigma;
        (void) offsetSigma;  // dummy to suppress unused var warning
        if (jacobian__)
            offsetSigma = in__.scalar_lb_constrain(MIN_SIGMA,lp__);
        else
            offsetSigma = in__.scalar_lb_constrain(MIN_SIGMA);

        T__ locTrendFract;
        (void) locTrendFract;  // dummy to suppress unused var warning
        if (jacobian__)
            locTrendFract = in__.scalar_lub_constrain(-(0.25),1,lp__);
        else
            locTrendFract = in__.scalar_lub_constrain(-(0.25),1);


        // transformed parameters
        T__ powTrend;
        (void) powTrend;  // dummy to suppress unused var warning

        stan::math::initialize(powTrend, DUMMY_VAR__);
        stan::math::fill(powTrend,DUMMY_VAR__);
        validate_non_negative_index("l", "N", N);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  l(static_cast<Eigen::VectorXd::Index>(N));
        (void) l;  // dummy to suppress unused var warning

        stan::math::initialize(l, DUMMY_VAR__);
        stan::math::fill(l,DUMMY_VAR__);
        validate_non_negative_index("b", "N", N);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  b(static_cast<Eigen::VectorXd::Index>(N));
        (void) b;  // dummy to suppress unused var warning

        stan::math::initialize(b, DUMMY_VAR__);
        stan::math::fill(b,DUMMY_VAR__);


        try {
            stan::math::assign(get_base1_lhs(l,1,"l",1), get_base1(y,1,"y",1));
            stan::math::assign(get_base1_lhs(b,1,"b",1), bInit);
            stan::math::assign(powTrend, (((MAX_POW_TREND - MIN_POW_TREND) * powTrendBeta) + MIN_POW_TREND));
            for (int t = 2; t <= N; ++t) {

                stan::math::assign(get_base1_lhs(l,t,"l",1), ((levSm * get_base1(y,t,"y",1)) + ((1 - levSm) * get_base1(l,(t - 1),"l",1))));
                stan::math::assign(get_base1_lhs(b,t,"b",1), ((bSm * (get_base1(l,t,"l",1) - get_base1(l,(t - 1),"l",1))) + ((1 - bSm) * get_base1(b,(t - 1),"b",1))));
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        if (stan::math::is_uninitialized(powTrend)) {
            std::stringstream msg__;
            msg__ << "Undefined transformed parameter: powTrend";
            throw std::runtime_error(msg__.str());
        }
        for (int i0__ = 0; i0__ < N; ++i0__) {
            if (stan::math::is_uninitialized(l(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: l" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < N; ++i0__) {
            if (stan::math::is_uninitialized(b(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: b" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }

        const char* function__ = "validate transformed params";
        (void) function__;  // dummy to suppress unused var warning
        check_greater_or_equal(function__,"powTrend",powTrend,MIN_POW_TREND);
        check_less_or_equal(function__,"powTrend",powTrend,MAX_POW_TREND);

        // model body
        try {

            lp_accum__.add(cauchy_log<propto__>(sigma, 0, CAUCHY_SD));
            if (sigma < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-cauchy_ccdf_log(0, 0, CAUCHY_SD));
            lp_accum__.add(cauchy_log<propto__>(offsetSigma, MIN_SIGMA, CAUCHY_SD));
            if (offsetSigma < MIN_SIGMA) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-cauchy_ccdf_log(MIN_SIGMA, MIN_SIGMA, CAUCHY_SD));
            lp_accum__.add(cauchy_log<propto__>(coefTrend, 0, CAUCHY_SD));
            lp_accum__.add(beta_log<propto__>(powTrendBeta, POW_TREND_ALPHA, POW_TREND_BETA));
            lp_accum__.add(beta_log<propto__>(powx, POW_SIGMA_ALPHA, POW_SIGMA_BETA));
            lp_accum__.add(normal_log<propto__>(bInit, 0, CAUCHY_SD));
            for (int t = 2; t <= N; ++t) {

                lp_accum__.add(student_t_log<propto__>(get_base1(y,t,"y",1), nu, ((get_base1(l,(t - 1),"l",1) + (coefTrend * pow(fabs(get_base1(l,(t - 1),"l",1)),powTrend))) + (locTrendFract * get_base1(b,(t - 1),"b",1))), ((sigma * pow(fabs(get_base1(l,(t - 1),"l",1)),powx)) + offsetSigma)));
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("nu");
        names__.push_back("sigma");
        names__.push_back("levSm");
        names__.push_back("bSm");
        names__.push_back("powx");
        names__.push_back("bInit");
        names__.push_back("powTrendBeta");
        names__.push_back("coefTrend");
        names__.push_back("offsetSigma");
        names__.push_back("locTrendFract");
        names__.push_back("powTrend");
        names__.push_back("l");
        names__.push_back("b");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_lgt_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double nu = in__.scalar_lub_constrain(MIN_NU,MAX_NU);
        double sigma = in__.scalar_lb_constrain(0);
        double levSm = in__.scalar_lub_constrain(0,1);
        double bSm = in__.scalar_lub_constrain(0,1);
        double powx = in__.scalar_lub_constrain(0,1);
        double bInit = in__.scalar_constrain();
        double powTrendBeta = in__.scalar_lub_constrain(0,1);
        double coefTrend = in__.scalar_constrain();
        double offsetSigma = in__.scalar_lb_constrain(MIN_SIGMA);
        double locTrendFract = in__.scalar_lub_constrain(-(0.25),1);
        vars__.push_back(nu);
        vars__.push_back(sigma);
        vars__.push_back(levSm);
        vars__.push_back(bSm);
        vars__.push_back(powx);
        vars__.push_back(bInit);
        vars__.push_back(powTrendBeta);
        vars__.push_back(coefTrend);
        vars__.push_back(offsetSigma);
        vars__.push_back(locTrendFract);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        double powTrend(0.0);
        (void) powTrend;  // dummy to suppress unused var warning

        stan::math::initialize(powTrend, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(powTrend,DUMMY_VAR__);
        validate_non_negative_index("l", "N", N);
        vector_d l(static_cast<Eigen::VectorXd::Index>(N));
        (void) l;  // dummy to suppress unused var warning

        stan::math::initialize(l, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(l,DUMMY_VAR__);
        validate_non_negative_index("b", "N", N);
        vector_d b(static_cast<Eigen::VectorXd::Index>(N));
        (void) b;  // dummy to suppress unused var warning

        stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b,DUMMY_VAR__);


        try {
            stan::math::assign(get_base1_lhs(l,1,"l",1), get_base1(y,1,"y",1));
            stan::math::assign(get_base1_lhs(b,1,"b",1), bInit);
            stan::math::assign(powTrend, (((MAX_POW_TREND - MIN_POW_TREND) * powTrendBeta) + MIN_POW_TREND));
            for (int t = 2; t <= N; ++t) {

                stan::math::assign(get_base1_lhs(l,t,"l",1), ((levSm * get_base1(y,t,"y",1)) + ((1 - levSm) * get_base1(l,(t - 1),"l",1))));
                stan::math::assign(get_base1_lhs(b,t,"b",1), ((bSm * (get_base1(l,t,"l",1) - get_base1(l,(t - 1),"l",1))) + ((1 - bSm) * get_base1(b,(t - 1),"b",1))));
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        check_greater_or_equal(function__,"powTrend",powTrend,MIN_POW_TREND);
        check_less_or_equal(function__,"powTrend",powTrend,MAX_POW_TREND);

        // write transformed parameters
        vars__.push_back(powTrend);
        for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(l[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b[k_0__]);
        }

        if (!include_gqs__) return;
        // declare and define generated quantities


        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate generated quantities

        // write generated quantities
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_lgt";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "nu";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "levSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "bSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powx";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "bInit";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrendBeta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "coefTrend";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "offsetSigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "locTrendFract";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrend";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "l" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "nu";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "levSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "bSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powx";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "bInit";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrendBeta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "coefTrend";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "offsetSigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "locTrendFract";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrend";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "l" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
    }

}; // model

}




// Code generated by Stan version 2.16.0

#include <stan/model/model_header.hpp>

namespace model_msgt_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_msgt");
    reader.add_event(157, 157, "end", "model_msgt");
    return reader;
}

class model_msgt : public prob_grad {
private:
    int NUM_OF_S2_DAYS;
    double CAUCHY_SD;
    double MIN_POW;
    double MAX_POW;
    double MIN_SIGMA;
    double MIN_NU;
    double MAX_NU;
    int N;
    vector_d y;
    vector<int> S2_INDEX;
    double TREND_ALPHA;
    double TREND_BETA;
    double POWX_ALPHA;
    double POWX_BETA;
    int S2_SEASONALITY;
    vector_d INIT_S2U;
    int YEARLY_SEASONALITY;
    int NWS;
    double NWS_real;
public:
    model_msgt(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_msgt(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_msgt_namespace::model_msgt";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        context__.validate_dims("data initialization", "NUM_OF_S2_DAYS", "int", context__.to_vec());
        NUM_OF_S2_DAYS = int(0);
        vals_i__ = context__.vals_i("NUM_OF_S2_DAYS");
        pos__ = 0;
        NUM_OF_S2_DAYS = vals_i__[pos__++];
        context__.validate_dims("data initialization", "CAUCHY_SD", "double", context__.to_vec());
        CAUCHY_SD = double(0);
        vals_r__ = context__.vals_r("CAUCHY_SD");
        pos__ = 0;
        CAUCHY_SD = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MIN_POW", "double", context__.to_vec());
        MIN_POW = double(0);
        vals_r__ = context__.vals_r("MIN_POW");
        pos__ = 0;
        MIN_POW = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MAX_POW", "double", context__.to_vec());
        MAX_POW = double(0);
        vals_r__ = context__.vals_r("MAX_POW");
        pos__ = 0;
        MAX_POW = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MIN_SIGMA", "double", context__.to_vec());
        MIN_SIGMA = double(0);
        vals_r__ = context__.vals_r("MIN_SIGMA");
        pos__ = 0;
        MIN_SIGMA = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MIN_NU", "double", context__.to_vec());
        MIN_NU = double(0);
        vals_r__ = context__.vals_r("MIN_NU");
        pos__ = 0;
        MIN_NU = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MAX_NU", "double", context__.to_vec());
        MAX_NU = double(0);
        vals_r__ = context__.vals_r("MAX_NU");
        pos__ = 0;
        MAX_NU = vals_r__[pos__++];
        context__.validate_dims("data initialization", "N", "int", context__.to_vec());
        N = int(0);
        vals_i__ = context__.vals_i("N");
        pos__ = 0;
        N = vals_i__[pos__++];
        validate_non_negative_index("y", "N", N);
        context__.validate_dims("data initialization", "y", "vector_d", context__.to_vec(N));
        validate_non_negative_index("y", "N", N);
        y = vector_d(static_cast<Eigen::VectorXd::Index>(N));
        vals_r__ = context__.vals_r("y");
        pos__ = 0;
        size_t y_i_vec_lim__ = N;
        for (size_t i_vec__ = 0; i_vec__ < y_i_vec_lim__; ++i_vec__) {
            y[i_vec__] = vals_r__[pos__++];
        }
        validate_non_negative_index("S2_INDEX", "N", N);
        context__.validate_dims("data initialization", "S2_INDEX", "int", context__.to_vec(N));
        validate_non_negative_index("S2_INDEX", "N", N);
        S2_INDEX = std::vector<int>(N,int(0));
        vals_i__ = context__.vals_i("S2_INDEX");
        pos__ = 0;
        size_t S2_INDEX_limit_0__ = N;
        for (size_t i_0__ = 0; i_0__ < S2_INDEX_limit_0__; ++i_0__) {
            S2_INDEX[i_0__] = vals_i__[pos__++];
        }
        context__.validate_dims("data initialization", "TREND_ALPHA", "double", context__.to_vec());
        TREND_ALPHA = double(0);
        vals_r__ = context__.vals_r("TREND_ALPHA");
        pos__ = 0;
        TREND_ALPHA = vals_r__[pos__++];
        context__.validate_dims("data initialization", "TREND_BETA", "double", context__.to_vec());
        TREND_BETA = double(0);
        vals_r__ = context__.vals_r("TREND_BETA");
        pos__ = 0;
        TREND_BETA = vals_r__[pos__++];
        context__.validate_dims("data initialization", "POWX_ALPHA", "double", context__.to_vec());
        POWX_ALPHA = double(0);
        vals_r__ = context__.vals_r("POWX_ALPHA");
        pos__ = 0;
        POWX_ALPHA = vals_r__[pos__++];
        context__.validate_dims("data initialization", "POWX_BETA", "double", context__.to_vec());
        POWX_BETA = double(0);
        vals_r__ = context__.vals_r("POWX_BETA");
        pos__ = 0;
        POWX_BETA = vals_r__[pos__++];
        context__.validate_dims("data initialization", "S2_SEASONALITY", "int", context__.to_vec());
        S2_SEASONALITY = int(0);
        vals_i__ = context__.vals_i("S2_SEASONALITY");
        pos__ = 0;
        S2_SEASONALITY = vals_i__[pos__++];
        validate_non_negative_index("INIT_S2U", "S2_SEASONALITY", S2_SEASONALITY);
        context__.validate_dims("data initialization", "INIT_S2U", "vector_d", context__.to_vec(S2_SEASONALITY));
        validate_non_negative_index("INIT_S2U", "S2_SEASONALITY", S2_SEASONALITY);
        INIT_S2U = vector_d(static_cast<Eigen::VectorXd::Index>(S2_SEASONALITY));
        vals_r__ = context__.vals_r("INIT_S2U");
        pos__ = 0;
        size_t INIT_S2U_i_vec_lim__ = S2_SEASONALITY;
        for (size_t i_vec__ = 0; i_vec__ < INIT_S2U_i_vec_lim__; ++i_vec__) {
            INIT_S2U[i_vec__] = vals_r__[pos__++];
        }

        // validate, data variables
        check_greater_or_equal(function__,"NUM_OF_S2_DAYS",NUM_OF_S2_DAYS,1);
        check_greater_or_equal(function__,"CAUCHY_SD",CAUCHY_SD,0);
        check_greater_or_equal(function__,"MIN_SIGMA",MIN_SIGMA,0);
        check_greater_or_equal(function__,"MIN_NU",MIN_NU,1);
        check_greater_or_equal(function__,"MAX_NU",MAX_NU,1);
        check_greater_or_equal(function__,"N",N,1);
        check_greater_or_equal(function__,"y",y,0);
        for (int k0__ = 0; k0__ < N; ++k0__) {
            check_greater_or_equal(function__,"S2_INDEX[k0__]",S2_INDEX[k0__],0);
            check_less_or_equal(function__,"S2_INDEX[k0__]",S2_INDEX[k0__],1);
        }
        check_greater_or_equal(function__,"TREND_ALPHA",TREND_ALPHA,0);
        check_greater_or_equal(function__,"TREND_BETA",TREND_BETA,0);
        check_greater_or_equal(function__,"POWX_ALPHA",POWX_ALPHA,0);
        check_greater_or_equal(function__,"POWX_BETA",POWX_BETA,0);
        check_greater_or_equal(function__,"S2_SEASONALITY",S2_SEASONALITY,2);
        // initialize data variables
        YEARLY_SEASONALITY = int(0);
        stan::math::fill(YEARLY_SEASONALITY, std::numeric_limits<int>::min());
        NWS = int(0);
        stan::math::fill(NWS, std::numeric_limits<int>::min());
        NWS_real = double(0);
        stan::math::fill(NWS_real,DUMMY_VAR__);

        try {
            stan::math::assign(YEARLY_SEASONALITY, 52);
            stan::math::assign(NWS_real, (((N / 7.0) + 1) + YEARLY_SEASONALITY));
            while (as_bool(logical_lt(NWS,NWS_real))) {

                stan::math::assign(NWS, (NWS + 1));
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed data
        check_greater_or_equal(function__,"YEARLY_SEASONALITY",YEARLY_SEASONALITY,2);
        check_greater_or_equal(function__,"NWS",NWS,1);

        // validate, set parameter ranges
        num_params_r__ = 0U;
        param_ranges_i__.clear();
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        validate_non_negative_index("initSu", "7", 7);
        num_params_r__ += 7;
        validate_non_negative_index("initS2u", "S2_SEASONALITY", S2_SEASONALITY);
        num_params_r__ += S2_SEASONALITY;
        validate_non_negative_index("initSyu", "YEARLY_SEASONALITY", YEARLY_SEASONALITY);
        num_params_r__ += YEARLY_SEASONALITY;
    }

    ~model_msgt() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("nu")))
            throw std::runtime_error("variable nu missing");
        vals_r__ = context__.vals_r("nu");
        pos__ = 0U;
        context__.validate_dims("initialization", "nu", "double", context__.to_vec());
        // generate_declaration nu
        double nu(0);
        nu = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(MIN_NU,MAX_NU,nu);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable nu: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma", "double", context__.to_vec());
        // generate_declaration sigma
        double sigma(0);
        sigma = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("powx")))
            throw std::runtime_error("variable powx missing");
        vals_r__ = context__.vals_r("powx");
        pos__ = 0U;
        context__.validate_dims("initialization", "powx", "double", context__.to_vec());
        // generate_declaration powx
        double powx(0);
        powx = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,powx);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable powx: ") + e.what());
        }

        if (!(context__.contains_r("offsetSigma")))
            throw std::runtime_error("variable offsetSigma missing");
        vals_r__ = context__.vals_r("offsetSigma");
        pos__ = 0U;
        context__.validate_dims("initialization", "offsetSigma", "double", context__.to_vec());
        // generate_declaration offsetSigma
        double offsetSigma(0);
        offsetSigma = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(MIN_SIGMA,offsetSigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable offsetSigma: ") + e.what());
        }

        if (!(context__.contains_r("sigma2")))
            throw std::runtime_error("variable sigma2 missing");
        vals_r__ = context__.vals_r("sigma2");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma2", "double", context__.to_vec());
        // generate_declaration sigma2
        double sigma2(0);
        sigma2 = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma2);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma2: ") + e.what());
        }

        if (!(context__.contains_r("powx2")))
            throw std::runtime_error("variable powx2 missing");
        vals_r__ = context__.vals_r("powx2");
        pos__ = 0U;
        context__.validate_dims("initialization", "powx2", "double", context__.to_vec());
        // generate_declaration powx2
        double powx2(0);
        powx2 = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,powx2);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable powx2: ") + e.what());
        }

        if (!(context__.contains_r("offsetSigma2")))
            throw std::runtime_error("variable offsetSigma2 missing");
        vals_r__ = context__.vals_r("offsetSigma2");
        pos__ = 0U;
        context__.validate_dims("initialization", "offsetSigma2", "double", context__.to_vec());
        // generate_declaration offsetSigma2
        double offsetSigma2(0);
        offsetSigma2 = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(MIN_SIGMA,offsetSigma2);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable offsetSigma2: ") + e.what());
        }

        if (!(context__.contains_r("levSm")))
            throw std::runtime_error("variable levSm missing");
        vals_r__ = context__.vals_r("levSm");
        pos__ = 0U;
        context__.validate_dims("initialization", "levSm", "double", context__.to_vec());
        // generate_declaration levSm
        double levSm(0);
        levSm = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,levSm);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable levSm: ") + e.what());
        }

        if (!(context__.contains_r("sSm")))
            throw std::runtime_error("variable sSm missing");
        vals_r__ = context__.vals_r("sSm");
        pos__ = 0U;
        context__.validate_dims("initialization", "sSm", "double", context__.to_vec());
        // generate_declaration sSm
        double sSm(0);
        sSm = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,sSm);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sSm: ") + e.what());
        }

        if (!(context__.contains_r("s2Sm")))
            throw std::runtime_error("variable s2Sm missing");
        vals_r__ = context__.vals_r("s2Sm");
        pos__ = 0U;
        context__.validate_dims("initialization", "s2Sm", "double", context__.to_vec());
        // generate_declaration s2Sm
        double s2Sm(0);
        s2Sm = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,s2Sm);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable s2Sm: ") + e.what());
        }

        if (!(context__.contains_r("sySm")))
            throw std::runtime_error("variable sySm missing");
        vals_r__ = context__.vals_r("sySm");
        pos__ = 0U;
        context__.validate_dims("initialization", "sySm", "double", context__.to_vec());
        // generate_declaration sySm
        double sySm(0);
        sySm = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,sySm);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sySm: ") + e.what());
        }

        if (!(context__.contains_r("powTrendBeta")))
            throw std::runtime_error("variable powTrendBeta missing");
        vals_r__ = context__.vals_r("powTrendBeta");
        pos__ = 0U;
        context__.validate_dims("initialization", "powTrendBeta", "double", context__.to_vec());
        // generate_declaration powTrendBeta
        double powTrendBeta(0);
        powTrendBeta = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,powTrendBeta);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable powTrendBeta: ") + e.what());
        }

        if (!(context__.contains_r("coefTrend")))
            throw std::runtime_error("variable coefTrend missing");
        vals_r__ = context__.vals_r("coefTrend");
        pos__ = 0U;
        context__.validate_dims("initialization", "coefTrend", "double", context__.to_vec());
        // generate_declaration coefTrend
        double coefTrend(0);
        coefTrend = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(coefTrend);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable coefTrend: ") + e.what());
        }

        if (!(context__.contains_r("initSu")))
            throw std::runtime_error("variable initSu missing");
        vals_r__ = context__.vals_r("initSu");
        pos__ = 0U;
        validate_non_negative_index("initSu", "7", 7);
        context__.validate_dims("initialization", "initSu", "vector_d", context__.to_vec(7));
        // generate_declaration initSu
        vector_d initSu(static_cast<Eigen::VectorXd::Index>(7));
        for (int j1__ = 0U; j1__ < 7; ++j1__)
            initSu(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(initSu);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable initSu: ") + e.what());
        }

        if (!(context__.contains_r("initS2u")))
            throw std::runtime_error("variable initS2u missing");
        vals_r__ = context__.vals_r("initS2u");
        pos__ = 0U;
        validate_non_negative_index("initS2u", "S2_SEASONALITY", S2_SEASONALITY);
        context__.validate_dims("initialization", "initS2u", "vector_d", context__.to_vec(S2_SEASONALITY));
        // generate_declaration initS2u
        vector_d initS2u(static_cast<Eigen::VectorXd::Index>(S2_SEASONALITY));
        for (int j1__ = 0U; j1__ < S2_SEASONALITY; ++j1__)
            initS2u(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(initS2u);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable initS2u: ") + e.what());
        }

        if (!(context__.contains_r("initSyu")))
            throw std::runtime_error("variable initSyu missing");
        vals_r__ = context__.vals_r("initSyu");
        pos__ = 0U;
        validate_non_negative_index("initSyu", "YEARLY_SEASONALITY", YEARLY_SEASONALITY);
        context__.validate_dims("initialization", "initSyu", "vector_d", context__.to_vec(YEARLY_SEASONALITY));
        // generate_declaration initSyu
        vector_d initSyu(static_cast<Eigen::VectorXd::Index>(YEARLY_SEASONALITY));
        for (int j1__ = 0U; j1__ < YEARLY_SEASONALITY; ++j1__)
            initSyu(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(initSyu);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable initSyu: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        // model parameters
        stan::io::reader<T__> in__(params_r__,params_i__);

        T__ nu;
        (void) nu;  // dummy to suppress unused var warning
        if (jacobian__)
            nu = in__.scalar_lub_constrain(MIN_NU,MAX_NU,lp__);
        else
            nu = in__.scalar_lub_constrain(MIN_NU,MAX_NU);

        T__ sigma;
        (void) sigma;  // dummy to suppress unused var warning
        if (jacobian__)
            sigma = in__.scalar_lb_constrain(0,lp__);
        else
            sigma = in__.scalar_lb_constrain(0);

        T__ powx;
        (void) powx;  // dummy to suppress unused var warning
        if (jacobian__)
            powx = in__.scalar_lub_constrain(0,1,lp__);
        else
            powx = in__.scalar_lub_constrain(0,1);

        T__ offsetSigma;
        (void) offsetSigma;  // dummy to suppress unused var warning
        if (jacobian__)
            offsetSigma = in__.scalar_lb_constrain(MIN_SIGMA,lp__);
        else
            offsetSigma = in__.scalar_lb_constrain(MIN_SIGMA);

        T__ sigma2;
        (void) sigma2;  // dummy to suppress unused var warning
        if (jacobian__)
            sigma2 = in__.scalar_lb_constrain(0,lp__);
        else
            sigma2 = in__.scalar_lb_constrain(0);

        T__ powx2;
        (void) powx2;  // dummy to suppress unused var warning
        if (jacobian__)
            powx2 = in__.scalar_lub_constrain(0,1,lp__);
        else
            powx2 = in__.scalar_lub_constrain(0,1);

        T__ offsetSigma2;
        (void) offsetSigma2;  // dummy to suppress unused var warning
        if (jacobian__)
            offsetSigma2 = in__.scalar_lb_constrain(MIN_SIGMA,lp__);
        else
            offsetSigma2 = in__.scalar_lb_constrain(MIN_SIGMA);

        T__ levSm;
        (void) levSm;  // dummy to suppress unused var warning
        if (jacobian__)
            levSm = in__.scalar_lub_constrain(0,1,lp__);
        else
            levSm = in__.scalar_lub_constrain(0,1);

        T__ sSm;
        (void) sSm;  // dummy to suppress unused var warning
        if (jacobian__)
            sSm = in__.scalar_lub_constrain(0,1,lp__);
        else
            sSm = in__.scalar_lub_constrain(0,1);

        T__ s2Sm;
        (void) s2Sm;  // dummy to suppress unused var warning
        if (jacobian__)
            s2Sm = in__.scalar_lub_constrain(0,1,lp__);
        else
            s2Sm = in__.scalar_lub_constrain(0,1);

        T__ sySm;
        (void) sySm;  // dummy to suppress unused var warning
        if (jacobian__)
            sySm = in__.scalar_lub_constrain(0,1,lp__);
        else
            sySm = in__.scalar_lub_constrain(0,1);

        T__ powTrendBeta;
        (void) powTrendBeta;  // dummy to suppress unused var warning
        if (jacobian__)
            powTrendBeta = in__.scalar_lub_constrain(0,1,lp__);
        else
            powTrendBeta = in__.scalar_lub_constrain(0,1);

        T__ coefTrend;
        (void) coefTrend;  // dummy to suppress unused var warning
        if (jacobian__)
            coefTrend = in__.scalar_constrain(lp__);
        else
            coefTrend = in__.scalar_constrain();

        Eigen::Matrix<T__,Eigen::Dynamic,1>  initSu;
        (void) initSu;  // dummy to suppress unused var warning
        if (jacobian__)
            initSu = in__.vector_constrain(7,lp__);
        else
            initSu = in__.vector_constrain(7);

        Eigen::Matrix<T__,Eigen::Dynamic,1>  initS2u;
        (void) initS2u;  // dummy to suppress unused var warning
        if (jacobian__)
            initS2u = in__.vector_constrain(S2_SEASONALITY,lp__);
        else
            initS2u = in__.vector_constrain(S2_SEASONALITY);

        Eigen::Matrix<T__,Eigen::Dynamic,1>  initSyu;
        (void) initSyu;  // dummy to suppress unused var warning
        if (jacobian__)
            initSyu = in__.vector_constrain(YEARLY_SEASONALITY,lp__);
        else
            initSyu = in__.vector_constrain(YEARLY_SEASONALITY);


        // transformed parameters
        T__ powTrend;
        (void) powTrend;  // dummy to suppress unused var warning

        stan::math::initialize(powTrend, DUMMY_VAR__);
        stan::math::fill(powTrend,DUMMY_VAR__);
        validate_non_negative_index("l", "N", N);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  l(static_cast<Eigen::VectorXd::Index>(N));
        (void) l;  // dummy to suppress unused var warning

        stan::math::initialize(l, DUMMY_VAR__);
        stan::math::fill(l,DUMMY_VAR__);
        validate_non_negative_index("inits", "7", 7);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  inits(static_cast<Eigen::VectorXd::Index>(7));
        (void) inits;  // dummy to suppress unused var warning

        stan::math::initialize(inits, DUMMY_VAR__);
        stan::math::fill(inits,DUMMY_VAR__);
        validate_non_negative_index("s", "((N + 7) + 1)", ((N + 7) + 1));
        Eigen::Matrix<T__,Eigen::Dynamic,1>  s(static_cast<Eigen::VectorXd::Index>(((N + 7) + 1)));
        (void) s;  // dummy to suppress unused var warning

        stan::math::initialize(s, DUMMY_VAR__);
        stan::math::fill(s,DUMMY_VAR__);
        validate_non_negative_index("inits2", "S2_SEASONALITY", S2_SEASONALITY);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  inits2(static_cast<Eigen::VectorXd::Index>(S2_SEASONALITY));
        (void) inits2;  // dummy to suppress unused var warning

        stan::math::initialize(inits2, DUMMY_VAR__);
        stan::math::fill(inits2,DUMMY_VAR__);
        validate_non_negative_index("s2", "((NUM_OF_S2_DAYS + S2_SEASONALITY) + 1)", ((NUM_OF_S2_DAYS + S2_SEASONALITY) + 1));
        Eigen::Matrix<T__,Eigen::Dynamic,1>  s2(static_cast<Eigen::VectorXd::Index>(((NUM_OF_S2_DAYS + S2_SEASONALITY) + 1)));
        (void) s2;  // dummy to suppress unused var warning

        stan::math::initialize(s2, DUMMY_VAR__);
        stan::math::fill(s2,DUMMY_VAR__);
        validate_non_negative_index("initSy", "YEARLY_SEASONALITY", YEARLY_SEASONALITY);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  initSy(static_cast<Eigen::VectorXd::Index>(YEARLY_SEASONALITY));
        (void) initSy;  // dummy to suppress unused var warning

        stan::math::initialize(initSy, DUMMY_VAR__);
        stan::math::fill(initSy,DUMMY_VAR__);
        validate_non_negative_index("sy", "NWS", NWS);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  sy(static_cast<Eigen::VectorXd::Index>(NWS));
        (void) sy;  // dummy to suppress unused var warning

        stan::math::initialize(sy, DUMMY_VAR__);
        stan::math::fill(sy,DUMMY_VAR__);
        T__ sumsu;
        (void) sumsu;  // dummy to suppress unused var warning

        stan::math::initialize(sumsu, DUMMY_VAR__);
        stan::math::fill(sumsu,DUMMY_VAR__);
        T__ sumy;
        (void) sumy;  // dummy to suppress unused var warning

        stan::math::initialize(sumy, DUMMY_VAR__);
        stan::math::fill(sumy,DUMMY_VAR__);


        try {
            stan::math::assign(sumsu, 0);
            for (int i = 1; i <= 7; ++i) {
                stan::math::assign(sumsu, (sumsu + get_base1(initSu,i,"initSu",1)));
            }
            for (int i = 1; i <= 7; ++i) {
                stan::math::assign(get_base1_lhs(inits,i,"inits",1), ((get_base1(initSu,i,"initSu",1) * 7) / sumsu));
            }
            for (int i = 1; i <= 7; ++i) {

                stan::math::assign(get_base1_lhs(s,i,"s",1), get_base1(inits,i,"inits",1));
            }
            stan::math::assign(get_base1_lhs(s,(7 + 1),"s",1), get_base1(inits,1,"inits",1));
            stan::math::assign(sumsu, 0);
            for (int i = 1; i <= S2_SEASONALITY; ++i) {
                stan::math::assign(sumsu, (sumsu + get_base1(initS2u,i,"initS2u",1)));
            }
            for (int i = 1; i <= S2_SEASONALITY; ++i) {
                stan::math::assign(get_base1_lhs(inits2,i,"inits2",1), ((get_base1(initS2u,i,"initS2u",1) * S2_SEASONALITY) / sumsu));
            }
            for (int i = 1; i <= S2_SEASONALITY; ++i) {

                stan::math::assign(get_base1_lhs(s2,i,"s2",1), (get_base1(inits2,i,"inits2",1) * get_base1(INIT_S2U,i,"INIT_S2U",1)));
            }
            stan::math::assign(sumsu, 0);
            for (int i = 1; i <= YEARLY_SEASONALITY; ++i) {
                stan::math::assign(sumsu, (sumsu + get_base1(initSyu,i,"initSyu",1)));
            }
            for (int i = 1; i <= YEARLY_SEASONALITY; ++i) {
                stan::math::assign(get_base1_lhs(initSy,i,"initSy",1), ((get_base1(initSyu,i,"initSyu",1) * YEARLY_SEASONALITY) / sumsu));
            }
            for (int i = 1; i <= YEARLY_SEASONALITY; ++i) {

                stan::math::assign(get_base1_lhs(sy,i,"sy",1), get_base1(initSy,i,"initSy",1));
            }
            if (as_bool(logical_eq(get_base1(S2_INDEX,1,"S2_INDEX",1),0))) {

                stan::math::assign(get_base1_lhs(l,1,"l",1), (get_base1(y,1,"y",1) / (get_base1(s,1,"s",1) * get_base1(sy,1,"sy",1))));
            } else {

                stan::math::assign(get_base1_lhs(l,1,"l",1), (get_base1(y,1,"y",1) / (get_base1(s2,1,"s2",1) * get_base1(sy,1,"sy",1))));
            }
            stan::math::assign(powTrend, (((MAX_POW - MIN_POW) * powTrendBeta) + MIN_POW));
            {
                int is2(0);
                (void) is2;  // dummy to suppress unused var warning

                stan::math::fill(is2, std::numeric_limits<int>::min());
                int iy(0);
                (void) iy;  // dummy to suppress unused var warning

                stan::math::fill(iy, std::numeric_limits<int>::min());


                stan::math::assign(sumy, 0);
                stan::math::assign(is2, 0);
                stan::math::assign(iy, 1);
                for (int t = 2; t <= N; ++t) {

                    if (as_bool(logical_eq(get_base1(S2_INDEX,t,"S2_INDEX",1),0))) {

                        stan::math::assign(get_base1_lhs(l,t,"l",1), (((levSm * get_base1(y,t,"y",1)) / (get_base1(s,t,"s",1) * get_base1(sy,iy,"sy",1))) + ((1 - levSm) * get_base1(l,(t - 1),"l",1))));
                        stan::math::assign(get_base1_lhs(s,(t + 7),"s",1), (((sSm * get_base1(y,t,"y",1)) / (get_base1(l,t,"l",1) * get_base1(sy,iy,"sy",1))) + ((1 - sSm) * get_base1(s,t,"s",1))));
                        stan::math::assign(sumy, (sumy + (get_base1(y,t,"y",1) / (get_base1(l,t,"l",1) * get_base1(s,t,"s",1)))));
                    } else {

                        stan::math::assign(is2, (is2 + 1));
                        stan::math::assign(get_base1_lhs(l,t,"l",1), (((levSm * get_base1(y,t,"y",1)) / (get_base1(s2,is2,"s2",1) * get_base1(sy,iy,"sy",1))) + ((1 - levSm) * get_base1(l,(t - 1),"l",1))));
                        stan::math::assign(get_base1_lhs(s2,(is2 + S2_SEASONALITY),"s2",1), (((s2Sm * get_base1(y,t,"y",1)) / (get_base1(l,t,"l",1) * get_base1(sy,iy,"sy",1))) + ((1 - s2Sm) * get_base1(s2,is2,"s2",1))));
                        stan::math::assign(get_base1_lhs(s,(t + 7),"s",1), get_base1(s,t,"s",1));
                        stan::math::assign(sumy, (sumy + (get_base1(y,t,"y",1) / (get_base1(l,t,"l",1) * get_base1(s2,is2,"s2",1)))));
                    }
                    if (as_bool(logical_eq(modulus((t - 1),7),0))) {

                        stan::math::assign(get_base1_lhs(sy,(iy + YEARLY_SEASONALITY),"sy",1), (((sySm * sumy) / 7) + ((1 - sySm) * get_base1(sy,iy,"sy",1))));
                        stan::math::assign(sumy, 0);
                        stan::math::assign(iy, (iy + 1));
                    }
                }
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        if (stan::math::is_uninitialized(powTrend)) {
            std::stringstream msg__;
            msg__ << "Undefined transformed parameter: powTrend";
            throw std::runtime_error(msg__.str());
        }
        for (int i0__ = 0; i0__ < N; ++i0__) {
            if (stan::math::is_uninitialized(l(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: l" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < 7; ++i0__) {
            if (stan::math::is_uninitialized(inits(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: inits" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < ((N + 7) + 1); ++i0__) {
            if (stan::math::is_uninitialized(s(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: s" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < S2_SEASONALITY; ++i0__) {
            if (stan::math::is_uninitialized(inits2(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: inits2" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < ((NUM_OF_S2_DAYS + S2_SEASONALITY) + 1); ++i0__) {
            if (stan::math::is_uninitialized(s2(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: s2" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < YEARLY_SEASONALITY; ++i0__) {
            if (stan::math::is_uninitialized(initSy(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: initSy" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < NWS; ++i0__) {
            if (stan::math::is_uninitialized(sy(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: sy" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        if (stan::math::is_uninitialized(sumsu)) {
            std::stringstream msg__;
            msg__ << "Undefined transformed parameter: sumsu";
            throw std::runtime_error(msg__.str());
        }
        if (stan::math::is_uninitialized(sumy)) {
            std::stringstream msg__;
            msg__ << "Undefined transformed parameter: sumy";
            throw std::runtime_error(msg__.str());
        }

        const char* function__ = "validate transformed params";
        (void) function__;  // dummy to suppress unused var warning
        check_greater_or_equal(function__,"powTrend",powTrend,MIN_POW);
        check_less_or_equal(function__,"powTrend",powTrend,MAX_POW);

        // model body
        try {
            {
                T__ expVal;
                (void) expVal;  // dummy to suppress unused var warning

                stan::math::initialize(expVal, DUMMY_VAR__);
                stan::math::fill(expVal,DUMMY_VAR__);
                T__ riy;
                (void) riy;  // dummy to suppress unused var warning

                stan::math::initialize(riy, DUMMY_VAR__);
                stan::math::fill(riy,DUMMY_VAR__);
                int is2(0);
                (void) is2;  // dummy to suppress unused var warning

                stan::math::fill(is2, std::numeric_limits<int>::min());
                int iy(0);
                (void) iy;  // dummy to suppress unused var warning

                stan::math::fill(iy, std::numeric_limits<int>::min());


                lp_accum__.add(beta_log<propto__>(powTrendBeta, TREND_ALPHA, TREND_BETA));
                lp_accum__.add(beta_log<propto__>(powx, POWX_ALPHA, POWX_BETA));
                lp_accum__.add(cauchy_log<propto__>(sigma, 0, CAUCHY_SD));
                if (sigma < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
                else lp_accum__.add(-cauchy_ccdf_log(0, 0, CAUCHY_SD));
                lp_accum__.add(cauchy_log<propto__>(offsetSigma, MIN_SIGMA, CAUCHY_SD));
                if (offsetSigma < MIN_SIGMA) lp_accum__.add(-std::numeric_limits<double>::infinity());
                else lp_accum__.add(-cauchy_ccdf_log(MIN_SIGMA, MIN_SIGMA, CAUCHY_SD));
                lp_accum__.add(cauchy_log<propto__>(sigma2, 0, (5 * CAUCHY_SD)));
                if (sigma2 < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
                else lp_accum__.add(-cauchy_ccdf_log(0, 0, (5 * CAUCHY_SD)));
                lp_accum__.add(cauchy_log<propto__>(offsetSigma2, MIN_SIGMA, (5 * CAUCHY_SD)));
                if (offsetSigma2 < MIN_SIGMA) lp_accum__.add(-std::numeric_limits<double>::infinity());
                else lp_accum__.add(-cauchy_ccdf_log(MIN_SIGMA, MIN_SIGMA, (5 * CAUCHY_SD)));
                lp_accum__.add(cauchy_log<propto__>(coefTrend, 0, CAUCHY_SD));
                for (int t = 1; t <= 7; ++t) {
                    lp_accum__.add(normal_log<propto__>(get_base1(initSu,t,"initSu",1), 1, 0.20000000000000001));
                    if (get_base1(initSu,t,"initSu",1) < 0.050000000000000003) lp_accum__.add(-std::numeric_limits<double>::infinity());
                    else lp_accum__.add(-normal_ccdf_log(0.050000000000000003, 1, 0.20000000000000001));
                }
                for (int t = 1; t <= S2_SEASONALITY; ++t) {
                    lp_accum__.add(normal_log<propto__>(get_base1(initS2u,t,"initS2u",1), 1, 0.20000000000000001));
                    if (get_base1(initS2u,t,"initS2u",1) < 0.10000000000000001) lp_accum__.add(-std::numeric_limits<double>::infinity());
                    else lp_accum__.add(-normal_ccdf_log(0.10000000000000001, 1, 0.20000000000000001));
                }
                for (int t = 1; t <= YEARLY_SEASONALITY; ++t) {
                    lp_accum__.add(normal_log<propto__>(get_base1(initSyu,t,"initSyu",1), 1, 0.29999999999999999));
                    if (get_base1(initSyu,t,"initSyu",1) < 0.050000000000000003) lp_accum__.add(-std::numeric_limits<double>::infinity());
                    else lp_accum__.add(-normal_ccdf_log(0.050000000000000003, 1, 0.29999999999999999));
                }
                stan::math::assign(is2, 0);
                for (int t = 2; t <= N; ++t) {

                    stan::math::assign(riy, (((t - 1) / 7.0) + 1));
                    while (as_bool(logical_lt(iy,riy))) {

                        stan::math::assign(iy, (iy + 1));
                    }
                    if (as_bool(logical_eq(get_base1(S2_INDEX,t,"S2_INDEX",1),0))) {

                        stan::math::assign(expVal, (((get_base1(l,(t - 1),"l",1) + (coefTrend * pow(fabs(get_base1(l,(t - 1),"l",1)),powTrend))) * get_base1(s,t,"s",1)) * get_base1(sy,iy,"sy",1)));
                        lp_accum__.add(student_t_log<propto__>(get_base1(y,t,"y",1), nu, expVal, ((sigma * pow(fabs(expVal),powx)) + offsetSigma)));
                    } else {

                        stan::math::assign(is2, (is2 + 1));
                        stan::math::assign(expVal, (((get_base1(l,(t - 1),"l",1) + (coefTrend * pow(fabs(get_base1(l,(t - 1),"l",1)),powTrend))) * get_base1(s2,is2,"s2",1)) * get_base1(sy,iy,"sy",1)));
                        lp_accum__.add(student_t_log<propto__>(get_base1(y,t,"y",1), nu, expVal, ((sigma2 * pow(fabs(expVal),powx2)) + offsetSigma2)));
                    }
                }
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("nu");
        names__.push_back("sigma");
        names__.push_back("powx");
        names__.push_back("offsetSigma");
        names__.push_back("sigma2");
        names__.push_back("powx2");
        names__.push_back("offsetSigma2");
        names__.push_back("levSm");
        names__.push_back("sSm");
        names__.push_back("s2Sm");
        names__.push_back("sySm");
        names__.push_back("powTrendBeta");
        names__.push_back("coefTrend");
        names__.push_back("initSu");
        names__.push_back("initS2u");
        names__.push_back("initSyu");
        names__.push_back("powTrend");
        names__.push_back("l");
        names__.push_back("inits");
        names__.push_back("s");
        names__.push_back("inits2");
        names__.push_back("s2");
        names__.push_back("initSy");
        names__.push_back("sy");
        names__.push_back("sumsu");
        names__.push_back("sumy");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(7);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(S2_SEASONALITY);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(YEARLY_SEASONALITY);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(7);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(((N + 7) + 1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(S2_SEASONALITY);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(((NUM_OF_S2_DAYS + S2_SEASONALITY) + 1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(YEARLY_SEASONALITY);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(NWS);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_msgt_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double nu = in__.scalar_lub_constrain(MIN_NU,MAX_NU);
        double sigma = in__.scalar_lb_constrain(0);
        double powx = in__.scalar_lub_constrain(0,1);
        double offsetSigma = in__.scalar_lb_constrain(MIN_SIGMA);
        double sigma2 = in__.scalar_lb_constrain(0);
        double powx2 = in__.scalar_lub_constrain(0,1);
        double offsetSigma2 = in__.scalar_lb_constrain(MIN_SIGMA);
        double levSm = in__.scalar_lub_constrain(0,1);
        double sSm = in__.scalar_lub_constrain(0,1);
        double s2Sm = in__.scalar_lub_constrain(0,1);
        double sySm = in__.scalar_lub_constrain(0,1);
        double powTrendBeta = in__.scalar_lub_constrain(0,1);
        double coefTrend = in__.scalar_constrain();
        vector_d initSu = in__.vector_constrain(7);
        vector_d initS2u = in__.vector_constrain(S2_SEASONALITY);
        vector_d initSyu = in__.vector_constrain(YEARLY_SEASONALITY);
        vars__.push_back(nu);
        vars__.push_back(sigma);
        vars__.push_back(powx);
        vars__.push_back(offsetSigma);
        vars__.push_back(sigma2);
        vars__.push_back(powx2);
        vars__.push_back(offsetSigma2);
        vars__.push_back(levSm);
        vars__.push_back(sSm);
        vars__.push_back(s2Sm);
        vars__.push_back(sySm);
        vars__.push_back(powTrendBeta);
        vars__.push_back(coefTrend);
        for (int k_0__ = 0; k_0__ < 7; ++k_0__) {
            vars__.push_back(initSu[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < S2_SEASONALITY; ++k_0__) {
            vars__.push_back(initS2u[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < YEARLY_SEASONALITY; ++k_0__) {
            vars__.push_back(initSyu[k_0__]);
        }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        double powTrend(0.0);
        (void) powTrend;  // dummy to suppress unused var warning

        stan::math::initialize(powTrend, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(powTrend,DUMMY_VAR__);
        validate_non_negative_index("l", "N", N);
        vector_d l(static_cast<Eigen::VectorXd::Index>(N));
        (void) l;  // dummy to suppress unused var warning

        stan::math::initialize(l, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(l,DUMMY_VAR__);
        validate_non_negative_index("inits", "7", 7);
        vector_d inits(static_cast<Eigen::VectorXd::Index>(7));
        (void) inits;  // dummy to suppress unused var warning

        stan::math::initialize(inits, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(inits,DUMMY_VAR__);
        validate_non_negative_index("s", "((N + 7) + 1)", ((N + 7) + 1));
        vector_d s(static_cast<Eigen::VectorXd::Index>(((N + 7) + 1)));
        (void) s;  // dummy to suppress unused var warning

        stan::math::initialize(s, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(s,DUMMY_VAR__);
        validate_non_negative_index("inits2", "S2_SEASONALITY", S2_SEASONALITY);
        vector_d inits2(static_cast<Eigen::VectorXd::Index>(S2_SEASONALITY));
        (void) inits2;  // dummy to suppress unused var warning

        stan::math::initialize(inits2, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(inits2,DUMMY_VAR__);
        validate_non_negative_index("s2", "((NUM_OF_S2_DAYS + S2_SEASONALITY) + 1)", ((NUM_OF_S2_DAYS + S2_SEASONALITY) + 1));
        vector_d s2(static_cast<Eigen::VectorXd::Index>(((NUM_OF_S2_DAYS + S2_SEASONALITY) + 1)));
        (void) s2;  // dummy to suppress unused var warning

        stan::math::initialize(s2, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(s2,DUMMY_VAR__);
        validate_non_negative_index("initSy", "YEARLY_SEASONALITY", YEARLY_SEASONALITY);
        vector_d initSy(static_cast<Eigen::VectorXd::Index>(YEARLY_SEASONALITY));
        (void) initSy;  // dummy to suppress unused var warning

        stan::math::initialize(initSy, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(initSy,DUMMY_VAR__);
        validate_non_negative_index("sy", "NWS", NWS);
        vector_d sy(static_cast<Eigen::VectorXd::Index>(NWS));
        (void) sy;  // dummy to suppress unused var warning

        stan::math::initialize(sy, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(sy,DUMMY_VAR__);
        double sumsu(0.0);
        (void) sumsu;  // dummy to suppress unused var warning

        stan::math::initialize(sumsu, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(sumsu,DUMMY_VAR__);
        double sumy(0.0);
        (void) sumy;  // dummy to suppress unused var warning

        stan::math::initialize(sumy, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(sumy,DUMMY_VAR__);


        try {
            stan::math::assign(sumsu, 0);
            for (int i = 1; i <= 7; ++i) {
                stan::math::assign(sumsu, (sumsu + get_base1(initSu,i,"initSu",1)));
            }
            for (int i = 1; i <= 7; ++i) {
                stan::math::assign(get_base1_lhs(inits,i,"inits",1), ((get_base1(initSu,i,"initSu",1) * 7) / sumsu));
            }
            for (int i = 1; i <= 7; ++i) {

                stan::math::assign(get_base1_lhs(s,i,"s",1), get_base1(inits,i,"inits",1));
            }
            stan::math::assign(get_base1_lhs(s,(7 + 1),"s",1), get_base1(inits,1,"inits",1));
            stan::math::assign(sumsu, 0);
            for (int i = 1; i <= S2_SEASONALITY; ++i) {
                stan::math::assign(sumsu, (sumsu + get_base1(initS2u,i,"initS2u",1)));
            }
            for (int i = 1; i <= S2_SEASONALITY; ++i) {
                stan::math::assign(get_base1_lhs(inits2,i,"inits2",1), ((get_base1(initS2u,i,"initS2u",1) * S2_SEASONALITY) / sumsu));
            }
            for (int i = 1; i <= S2_SEASONALITY; ++i) {

                stan::math::assign(get_base1_lhs(s2,i,"s2",1), (get_base1(inits2,i,"inits2",1) * get_base1(INIT_S2U,i,"INIT_S2U",1)));
            }
            stan::math::assign(sumsu, 0);
            for (int i = 1; i <= YEARLY_SEASONALITY; ++i) {
                stan::math::assign(sumsu, (sumsu + get_base1(initSyu,i,"initSyu",1)));
            }
            for (int i = 1; i <= YEARLY_SEASONALITY; ++i) {
                stan::math::assign(get_base1_lhs(initSy,i,"initSy",1), ((get_base1(initSyu,i,"initSyu",1) * YEARLY_SEASONALITY) / sumsu));
            }
            for (int i = 1; i <= YEARLY_SEASONALITY; ++i) {

                stan::math::assign(get_base1_lhs(sy,i,"sy",1), get_base1(initSy,i,"initSy",1));
            }
            if (as_bool(logical_eq(get_base1(S2_INDEX,1,"S2_INDEX",1),0))) {

                stan::math::assign(get_base1_lhs(l,1,"l",1), (get_base1(y,1,"y",1) / (get_base1(s,1,"s",1) * get_base1(sy,1,"sy",1))));
            } else {

                stan::math::assign(get_base1_lhs(l,1,"l",1), (get_base1(y,1,"y",1) / (get_base1(s2,1,"s2",1) * get_base1(sy,1,"sy",1))));
            }
            stan::math::assign(powTrend, (((MAX_POW - MIN_POW) * powTrendBeta) + MIN_POW));
            {
                int is2(0);
                (void) is2;  // dummy to suppress unused var warning

                stan::math::fill(is2, std::numeric_limits<int>::min());
                int iy(0);
                (void) iy;  // dummy to suppress unused var warning

                stan::math::fill(iy, std::numeric_limits<int>::min());


                stan::math::assign(sumy, 0);
                stan::math::assign(is2, 0);
                stan::math::assign(iy, 1);
                for (int t = 2; t <= N; ++t) {

                    if (as_bool(logical_eq(get_base1(S2_INDEX,t,"S2_INDEX",1),0))) {

                        stan::math::assign(get_base1_lhs(l,t,"l",1), (((levSm * get_base1(y,t,"y",1)) / (get_base1(s,t,"s",1) * get_base1(sy,iy,"sy",1))) + ((1 - levSm) * get_base1(l,(t - 1),"l",1))));
                        stan::math::assign(get_base1_lhs(s,(t + 7),"s",1), (((sSm * get_base1(y,t,"y",1)) / (get_base1(l,t,"l",1) * get_base1(sy,iy,"sy",1))) + ((1 - sSm) * get_base1(s,t,"s",1))));
                        stan::math::assign(sumy, (sumy + (get_base1(y,t,"y",1) / (get_base1(l,t,"l",1) * get_base1(s,t,"s",1)))));
                    } else {

                        stan::math::assign(is2, (is2 + 1));
                        stan::math::assign(get_base1_lhs(l,t,"l",1), (((levSm * get_base1(y,t,"y",1)) / (get_base1(s2,is2,"s2",1) * get_base1(sy,iy,"sy",1))) + ((1 - levSm) * get_base1(l,(t - 1),"l",1))));
                        stan::math::assign(get_base1_lhs(s2,(is2 + S2_SEASONALITY),"s2",1), (((s2Sm * get_base1(y,t,"y",1)) / (get_base1(l,t,"l",1) * get_base1(sy,iy,"sy",1))) + ((1 - s2Sm) * get_base1(s2,is2,"s2",1))));
                        stan::math::assign(get_base1_lhs(s,(t + 7),"s",1), get_base1(s,t,"s",1));
                        stan::math::assign(sumy, (sumy + (get_base1(y,t,"y",1) / (get_base1(l,t,"l",1) * get_base1(s2,is2,"s2",1)))));
                    }
                    if (as_bool(logical_eq(modulus((t - 1),7),0))) {

                        stan::math::assign(get_base1_lhs(sy,(iy + YEARLY_SEASONALITY),"sy",1), (((sySm * sumy) / 7) + ((1 - sySm) * get_base1(sy,iy,"sy",1))));
                        stan::math::assign(sumy, 0);
                        stan::math::assign(iy, (iy + 1));
                    }
                }
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        check_greater_or_equal(function__,"powTrend",powTrend,MIN_POW);
        check_less_or_equal(function__,"powTrend",powTrend,MAX_POW);

        // write transformed parameters
        vars__.push_back(powTrend);
        for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(l[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < 7; ++k_0__) {
            vars__.push_back(inits[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < ((N + 7) + 1); ++k_0__) {
            vars__.push_back(s[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < S2_SEASONALITY; ++k_0__) {
            vars__.push_back(inits2[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < ((NUM_OF_S2_DAYS + S2_SEASONALITY) + 1); ++k_0__) {
            vars__.push_back(s2[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < YEARLY_SEASONALITY; ++k_0__) {
            vars__.push_back(initSy[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < NWS; ++k_0__) {
            vars__.push_back(sy[k_0__]);
        }
        vars__.push_back(sumsu);
        vars__.push_back(sumy);

        if (!include_gqs__) return;
        // declare and define generated quantities


        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate generated quantities

        // write generated quantities
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_msgt";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "nu";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powx";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "offsetSigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma2";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powx2";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "offsetSigma2";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "levSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "s2Sm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sySm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrendBeta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "coefTrend";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= 7; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "initSu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= S2_SEASONALITY; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "initS2u" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= YEARLY_SEASONALITY; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "initSyu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrend";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "l" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 7; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "inits" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= ((N + 7) + 1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "s" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= S2_SEASONALITY; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "inits2" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= ((NUM_OF_S2_DAYS + S2_SEASONALITY) + 1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "s2" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= YEARLY_SEASONALITY; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "initSy" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= NWS; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sy" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sumsu";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sumy";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "nu";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powx";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "offsetSigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma2";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powx2";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "offsetSigma2";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "levSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "s2Sm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sySm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrendBeta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "coefTrend";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= 7; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "initSu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= S2_SEASONALITY; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "initS2u" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= YEARLY_SEASONALITY; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "initSyu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrend";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "l" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 7; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "inits" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= ((N + 7) + 1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "s" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= S2_SEASONALITY; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "inits2" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= ((NUM_OF_S2_DAYS + S2_SEASONALITY) + 1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "s2" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= YEARLY_SEASONALITY; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "initSy" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= NWS; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sy" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sumsu";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sumy";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
    }

}; // model

}




// Code generated by Stan version 2.16.0

#include <stan/model/model_header.hpp>

namespace model_sgt_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_sgt");
    reader.add_event(68, 68, "end", "model_sgt");
    return reader;
}

class model_sgt : public prob_grad {
private:
    int SEASONALITY;
    double CAUCHY_SD;
    double MIN_POW_TREND;
    double MAX_POW_TREND;
    double MIN_SIGMA;
    double MIN_NU;
    double MAX_NU;
    int N;
    vector_d y;
    double POW_TREND_ALPHA;
    double POW_TREND_BETA;
    double POW_SIGMA_ALPHA;
    double POW_SIGMA_BETA;
public:
    model_sgt(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_sgt(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_sgt_namespace::model_sgt";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        context__.validate_dims("data initialization", "SEASONALITY", "int", context__.to_vec());
        SEASONALITY = int(0);
        vals_i__ = context__.vals_i("SEASONALITY");
        pos__ = 0;
        SEASONALITY = vals_i__[pos__++];
        context__.validate_dims("data initialization", "CAUCHY_SD", "double", context__.to_vec());
        CAUCHY_SD = double(0);
        vals_r__ = context__.vals_r("CAUCHY_SD");
        pos__ = 0;
        CAUCHY_SD = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MIN_POW_TREND", "double", context__.to_vec());
        MIN_POW_TREND = double(0);
        vals_r__ = context__.vals_r("MIN_POW_TREND");
        pos__ = 0;
        MIN_POW_TREND = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MAX_POW_TREND", "double", context__.to_vec());
        MAX_POW_TREND = double(0);
        vals_r__ = context__.vals_r("MAX_POW_TREND");
        pos__ = 0;
        MAX_POW_TREND = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MIN_SIGMA", "double", context__.to_vec());
        MIN_SIGMA = double(0);
        vals_r__ = context__.vals_r("MIN_SIGMA");
        pos__ = 0;
        MIN_SIGMA = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MIN_NU", "double", context__.to_vec());
        MIN_NU = double(0);
        vals_r__ = context__.vals_r("MIN_NU");
        pos__ = 0;
        MIN_NU = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MAX_NU", "double", context__.to_vec());
        MAX_NU = double(0);
        vals_r__ = context__.vals_r("MAX_NU");
        pos__ = 0;
        MAX_NU = vals_r__[pos__++];
        context__.validate_dims("data initialization", "N", "int", context__.to_vec());
        N = int(0);
        vals_i__ = context__.vals_i("N");
        pos__ = 0;
        N = vals_i__[pos__++];
        validate_non_negative_index("y", "N", N);
        context__.validate_dims("data initialization", "y", "vector_d", context__.to_vec(N));
        validate_non_negative_index("y", "N", N);
        y = vector_d(static_cast<Eigen::VectorXd::Index>(N));
        vals_r__ = context__.vals_r("y");
        pos__ = 0;
        size_t y_i_vec_lim__ = N;
        for (size_t i_vec__ = 0; i_vec__ < y_i_vec_lim__; ++i_vec__) {
            y[i_vec__] = vals_r__[pos__++];
        }
        context__.validate_dims("data initialization", "POW_TREND_ALPHA", "double", context__.to_vec());
        POW_TREND_ALPHA = double(0);
        vals_r__ = context__.vals_r("POW_TREND_ALPHA");
        pos__ = 0;
        POW_TREND_ALPHA = vals_r__[pos__++];
        context__.validate_dims("data initialization", "POW_TREND_BETA", "double", context__.to_vec());
        POW_TREND_BETA = double(0);
        vals_r__ = context__.vals_r("POW_TREND_BETA");
        pos__ = 0;
        POW_TREND_BETA = vals_r__[pos__++];
        context__.validate_dims("data initialization", "POW_SIGMA_ALPHA", "double", context__.to_vec());
        POW_SIGMA_ALPHA = double(0);
        vals_r__ = context__.vals_r("POW_SIGMA_ALPHA");
        pos__ = 0;
        POW_SIGMA_ALPHA = vals_r__[pos__++];
        context__.validate_dims("data initialization", "POW_SIGMA_BETA", "double", context__.to_vec());
        POW_SIGMA_BETA = double(0);
        vals_r__ = context__.vals_r("POW_SIGMA_BETA");
        pos__ = 0;
        POW_SIGMA_BETA = vals_r__[pos__++];

        // validate, data variables
        check_greater_or_equal(function__,"SEASONALITY",SEASONALITY,2);
        check_greater_or_equal(function__,"CAUCHY_SD",CAUCHY_SD,0);
        check_greater_or_equal(function__,"MIN_SIGMA",MIN_SIGMA,0);
        check_greater_or_equal(function__,"MIN_NU",MIN_NU,1);
        check_greater_or_equal(function__,"MAX_NU",MAX_NU,1);
        check_greater_or_equal(function__,"N",N,1);
        check_greater_or_equal(function__,"y",y,0);
        check_greater_or_equal(function__,"POW_TREND_ALPHA",POW_TREND_ALPHA,0);
        check_greater_or_equal(function__,"POW_TREND_BETA",POW_TREND_BETA,0);
        check_greater_or_equal(function__,"POW_SIGMA_ALPHA",POW_SIGMA_ALPHA,0);
        check_greater_or_equal(function__,"POW_SIGMA_BETA",POW_SIGMA_BETA,0);
        // initialize data variables

        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed data

        // validate, set parameter ranges
        num_params_r__ = 0U;
        param_ranges_i__.clear();
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        validate_non_negative_index("initSu", "SEASONALITY", SEASONALITY);
        num_params_r__ += SEASONALITY;
    }

    ~model_sgt() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("nu")))
            throw std::runtime_error("variable nu missing");
        vals_r__ = context__.vals_r("nu");
        pos__ = 0U;
        context__.validate_dims("initialization", "nu", "double", context__.to_vec());
        // generate_declaration nu
        double nu(0);
        nu = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(MIN_NU,MAX_NU,nu);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable nu: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma", "double", context__.to_vec());
        // generate_declaration sigma
        double sigma(0);
        sigma = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("levSm")))
            throw std::runtime_error("variable levSm missing");
        vals_r__ = context__.vals_r("levSm");
        pos__ = 0U;
        context__.validate_dims("initialization", "levSm", "double", context__.to_vec());
        // generate_declaration levSm
        double levSm(0);
        levSm = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,levSm);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable levSm: ") + e.what());
        }

        if (!(context__.contains_r("sSm")))
            throw std::runtime_error("variable sSm missing");
        vals_r__ = context__.vals_r("sSm");
        pos__ = 0U;
        context__.validate_dims("initialization", "sSm", "double", context__.to_vec());
        // generate_declaration sSm
        double sSm(0);
        sSm = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,sSm);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sSm: ") + e.what());
        }

        if (!(context__.contains_r("powx")))
            throw std::runtime_error("variable powx missing");
        vals_r__ = context__.vals_r("powx");
        pos__ = 0U;
        context__.validate_dims("initialization", "powx", "double", context__.to_vec());
        // generate_declaration powx
        double powx(0);
        powx = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,powx);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable powx: ") + e.what());
        }

        if (!(context__.contains_r("powTrendBeta")))
            throw std::runtime_error("variable powTrendBeta missing");
        vals_r__ = context__.vals_r("powTrendBeta");
        pos__ = 0U;
        context__.validate_dims("initialization", "powTrendBeta", "double", context__.to_vec());
        // generate_declaration powTrendBeta
        double powTrendBeta(0);
        powTrendBeta = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,powTrendBeta);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable powTrendBeta: ") + e.what());
        }

        if (!(context__.contains_r("coefTrend")))
            throw std::runtime_error("variable coefTrend missing");
        vals_r__ = context__.vals_r("coefTrend");
        pos__ = 0U;
        context__.validate_dims("initialization", "coefTrend", "double", context__.to_vec());
        // generate_declaration coefTrend
        double coefTrend(0);
        coefTrend = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(coefTrend);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable coefTrend: ") + e.what());
        }

        if (!(context__.contains_r("offsetSigma")))
            throw std::runtime_error("variable offsetSigma missing");
        vals_r__ = context__.vals_r("offsetSigma");
        pos__ = 0U;
        context__.validate_dims("initialization", "offsetSigma", "double", context__.to_vec());
        // generate_declaration offsetSigma
        double offsetSigma(0);
        offsetSigma = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(MIN_SIGMA,offsetSigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable offsetSigma: ") + e.what());
        }

        if (!(context__.contains_r("initSu")))
            throw std::runtime_error("variable initSu missing");
        vals_r__ = context__.vals_r("initSu");
        pos__ = 0U;
        validate_non_negative_index("initSu", "SEASONALITY", SEASONALITY);
        context__.validate_dims("initialization", "initSu", "vector_d", context__.to_vec(SEASONALITY));
        // generate_declaration initSu
        vector_d initSu(static_cast<Eigen::VectorXd::Index>(SEASONALITY));
        for (int j1__ = 0U; j1__ < SEASONALITY; ++j1__)
            initSu(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(initSu);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable initSu: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        // model parameters
        stan::io::reader<T__> in__(params_r__,params_i__);

        T__ nu;
        (void) nu;  // dummy to suppress unused var warning
        if (jacobian__)
            nu = in__.scalar_lub_constrain(MIN_NU,MAX_NU,lp__);
        else
            nu = in__.scalar_lub_constrain(MIN_NU,MAX_NU);

        T__ sigma;
        (void) sigma;  // dummy to suppress unused var warning
        if (jacobian__)
            sigma = in__.scalar_lb_constrain(0,lp__);
        else
            sigma = in__.scalar_lb_constrain(0);

        T__ levSm;
        (void) levSm;  // dummy to suppress unused var warning
        if (jacobian__)
            levSm = in__.scalar_lub_constrain(0,1,lp__);
        else
            levSm = in__.scalar_lub_constrain(0,1);

        T__ sSm;
        (void) sSm;  // dummy to suppress unused var warning
        if (jacobian__)
            sSm = in__.scalar_lub_constrain(0,1,lp__);
        else
            sSm = in__.scalar_lub_constrain(0,1);

        T__ powx;
        (void) powx;  // dummy to suppress unused var warning
        if (jacobian__)
            powx = in__.scalar_lub_constrain(0,1,lp__);
        else
            powx = in__.scalar_lub_constrain(0,1);

        T__ powTrendBeta;
        (void) powTrendBeta;  // dummy to suppress unused var warning
        if (jacobian__)
            powTrendBeta = in__.scalar_lub_constrain(0,1,lp__);
        else
            powTrendBeta = in__.scalar_lub_constrain(0,1);

        T__ coefTrend;
        (void) coefTrend;  // dummy to suppress unused var warning
        if (jacobian__)
            coefTrend = in__.scalar_constrain(lp__);
        else
            coefTrend = in__.scalar_constrain();

        T__ offsetSigma;
        (void) offsetSigma;  // dummy to suppress unused var warning
        if (jacobian__)
            offsetSigma = in__.scalar_lb_constrain(MIN_SIGMA,lp__);
        else
            offsetSigma = in__.scalar_lb_constrain(MIN_SIGMA);

        Eigen::Matrix<T__,Eigen::Dynamic,1>  initSu;
        (void) initSu;  // dummy to suppress unused var warning
        if (jacobian__)
            initSu = in__.vector_constrain(SEASONALITY,lp__);
        else
            initSu = in__.vector_constrain(SEASONALITY);


        // transformed parameters
        T__ powTrend;
        (void) powTrend;  // dummy to suppress unused var warning

        stan::math::initialize(powTrend, DUMMY_VAR__);
        stan::math::fill(powTrend,DUMMY_VAR__);
        validate_non_negative_index("l", "N", N);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  l(static_cast<Eigen::VectorXd::Index>(N));
        (void) l;  // dummy to suppress unused var warning

        stan::math::initialize(l, DUMMY_VAR__);
        stan::math::fill(l,DUMMY_VAR__);
        validate_non_negative_index("inits", "SEASONALITY", SEASONALITY);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  inits(static_cast<Eigen::VectorXd::Index>(SEASONALITY));
        (void) inits;  // dummy to suppress unused var warning

        stan::math::initialize(inits, DUMMY_VAR__);
        stan::math::fill(inits,DUMMY_VAR__);
        validate_non_negative_index("s", "(N + SEASONALITY)", (N + SEASONALITY));
        Eigen::Matrix<T__,Eigen::Dynamic,1>  s(static_cast<Eigen::VectorXd::Index>((N + SEASONALITY)));
        (void) s;  // dummy to suppress unused var warning

        stan::math::initialize(s, DUMMY_VAR__);
        stan::math::fill(s,DUMMY_VAR__);
        T__ sumsu;
        (void) sumsu;  // dummy to suppress unused var warning

        stan::math::initialize(sumsu, DUMMY_VAR__);
        stan::math::fill(sumsu,DUMMY_VAR__);


        try {
            stan::math::assign(sumsu, 0);
            for (int i = 1; i <= SEASONALITY; ++i) {
                stan::math::assign(sumsu, (sumsu + get_base1(initSu,i,"initSu",1)));
            }
            for (int i = 1; i <= SEASONALITY; ++i) {
                stan::math::assign(get_base1_lhs(inits,i,"inits",1), ((get_base1(initSu,i,"initSu",1) * SEASONALITY) / sumsu));
            }
            for (int i = 1; i <= SEASONALITY; ++i) {

                stan::math::assign(get_base1_lhs(s,i,"s",1), get_base1(inits,i,"inits",1));
            }
            stan::math::assign(get_base1_lhs(s,(SEASONALITY + 1),"s",1), get_base1(inits,1,"inits",1));
            stan::math::assign(get_base1_lhs(l,1,"l",1), (get_base1(y,1,"y",1) / get_base1(s,1,"s",1)));
            stan::math::assign(powTrend, (((MAX_POW_TREND - MIN_POW_TREND) * powTrendBeta) + MIN_POW_TREND));
            for (int t = 2; t <= N; ++t) {

                stan::math::assign(get_base1_lhs(l,t,"l",1), (((levSm * get_base1(y,t,"y",1)) / get_base1(s,t,"s",1)) + ((1 - levSm) * get_base1(l,(t - 1),"l",1))));
                stan::math::assign(get_base1_lhs(s,(t + SEASONALITY),"s",1), (((sSm * get_base1(y,t,"y",1)) / get_base1(l,t,"l",1)) + ((1 - sSm) * get_base1(s,t,"s",1))));
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        if (stan::math::is_uninitialized(powTrend)) {
            std::stringstream msg__;
            msg__ << "Undefined transformed parameter: powTrend";
            throw std::runtime_error(msg__.str());
        }
        for (int i0__ = 0; i0__ < N; ++i0__) {
            if (stan::math::is_uninitialized(l(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: l" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < SEASONALITY; ++i0__) {
            if (stan::math::is_uninitialized(inits(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: inits" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < (N + SEASONALITY); ++i0__) {
            if (stan::math::is_uninitialized(s(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: s" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        if (stan::math::is_uninitialized(sumsu)) {
            std::stringstream msg__;
            msg__ << "Undefined transformed parameter: sumsu";
            throw std::runtime_error(msg__.str());
        }

        const char* function__ = "validate transformed params";
        (void) function__;  // dummy to suppress unused var warning
        check_greater_or_equal(function__,"powTrend",powTrend,MIN_POW_TREND);
        check_less_or_equal(function__,"powTrend",powTrend,MAX_POW_TREND);

        // model body
        try {
            {
                T__ expVal;
                (void) expVal;  // dummy to suppress unused var warning

                stan::math::initialize(expVal, DUMMY_VAR__);
                stan::math::fill(expVal,DUMMY_VAR__);


                lp_accum__.add(cauchy_log<propto__>(sigma, 0, CAUCHY_SD));
                if (sigma < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
                else lp_accum__.add(-cauchy_ccdf_log(0, 0, CAUCHY_SD));
                lp_accum__.add(cauchy_log<propto__>(offsetSigma, MIN_SIGMA, CAUCHY_SD));
                if (offsetSigma < MIN_SIGMA) lp_accum__.add(-std::numeric_limits<double>::infinity());
                else lp_accum__.add(-cauchy_ccdf_log(MIN_SIGMA, MIN_SIGMA, CAUCHY_SD));
                lp_accum__.add(cauchy_log<propto__>(coefTrend, 0, CAUCHY_SD));
                lp_accum__.add(beta_log<propto__>(powTrendBeta, POW_TREND_ALPHA, POW_TREND_BETA));
                lp_accum__.add(beta_log<propto__>(powx, POW_SIGMA_ALPHA, POW_SIGMA_BETA));
                for (int t = 1; t <= SEASONALITY; ++t) {

                    lp_accum__.add(normal_log<propto__>(get_base1(initSu,t,"initSu",1), 1, 0.29999999999999999));
                    if (get_base1(initSu,t,"initSu",1) < 0.01) lp_accum__.add(-std::numeric_limits<double>::infinity());
                    else lp_accum__.add(-normal_ccdf_log(0.01, 1, 0.29999999999999999));
                }
                for (int t = 2; t <= N; ++t) {

                    stan::math::assign(expVal, ((get_base1(l,(t - 1),"l",1) + (coefTrend * pow(fabs(get_base1(l,(t - 1),"l",1)),powTrend))) * get_base1(s,t,"s",1)));
                    lp_accum__.add(student_t_log<propto__>(get_base1(y,t,"y",1), nu, expVal, ((sigma * pow(fabs(expVal),powx)) + offsetSigma)));
                }
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("nu");
        names__.push_back("sigma");
        names__.push_back("levSm");
        names__.push_back("sSm");
        names__.push_back("powx");
        names__.push_back("powTrendBeta");
        names__.push_back("coefTrend");
        names__.push_back("offsetSigma");
        names__.push_back("initSu");
        names__.push_back("powTrend");
        names__.push_back("l");
        names__.push_back("inits");
        names__.push_back("s");
        names__.push_back("sumsu");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(SEASONALITY);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(SEASONALITY);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((N + SEASONALITY));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_sgt_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double nu = in__.scalar_lub_constrain(MIN_NU,MAX_NU);
        double sigma = in__.scalar_lb_constrain(0);
        double levSm = in__.scalar_lub_constrain(0,1);
        double sSm = in__.scalar_lub_constrain(0,1);
        double powx = in__.scalar_lub_constrain(0,1);
        double powTrendBeta = in__.scalar_lub_constrain(0,1);
        double coefTrend = in__.scalar_constrain();
        double offsetSigma = in__.scalar_lb_constrain(MIN_SIGMA);
        vector_d initSu = in__.vector_constrain(SEASONALITY);
        vars__.push_back(nu);
        vars__.push_back(sigma);
        vars__.push_back(levSm);
        vars__.push_back(sSm);
        vars__.push_back(powx);
        vars__.push_back(powTrendBeta);
        vars__.push_back(coefTrend);
        vars__.push_back(offsetSigma);
        for (int k_0__ = 0; k_0__ < SEASONALITY; ++k_0__) {
            vars__.push_back(initSu[k_0__]);
        }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        double powTrend(0.0);
        (void) powTrend;  // dummy to suppress unused var warning

        stan::math::initialize(powTrend, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(powTrend,DUMMY_VAR__);
        validate_non_negative_index("l", "N", N);
        vector_d l(static_cast<Eigen::VectorXd::Index>(N));
        (void) l;  // dummy to suppress unused var warning

        stan::math::initialize(l, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(l,DUMMY_VAR__);
        validate_non_negative_index("inits", "SEASONALITY", SEASONALITY);
        vector_d inits(static_cast<Eigen::VectorXd::Index>(SEASONALITY));
        (void) inits;  // dummy to suppress unused var warning

        stan::math::initialize(inits, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(inits,DUMMY_VAR__);
        validate_non_negative_index("s", "(N + SEASONALITY)", (N + SEASONALITY));
        vector_d s(static_cast<Eigen::VectorXd::Index>((N + SEASONALITY)));
        (void) s;  // dummy to suppress unused var warning

        stan::math::initialize(s, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(s,DUMMY_VAR__);
        double sumsu(0.0);
        (void) sumsu;  // dummy to suppress unused var warning

        stan::math::initialize(sumsu, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(sumsu,DUMMY_VAR__);


        try {
            stan::math::assign(sumsu, 0);
            for (int i = 1; i <= SEASONALITY; ++i) {
                stan::math::assign(sumsu, (sumsu + get_base1(initSu,i,"initSu",1)));
            }
            for (int i = 1; i <= SEASONALITY; ++i) {
                stan::math::assign(get_base1_lhs(inits,i,"inits",1), ((get_base1(initSu,i,"initSu",1) * SEASONALITY) / sumsu));
            }
            for (int i = 1; i <= SEASONALITY; ++i) {

                stan::math::assign(get_base1_lhs(s,i,"s",1), get_base1(inits,i,"inits",1));
            }
            stan::math::assign(get_base1_lhs(s,(SEASONALITY + 1),"s",1), get_base1(inits,1,"inits",1));
            stan::math::assign(get_base1_lhs(l,1,"l",1), (get_base1(y,1,"y",1) / get_base1(s,1,"s",1)));
            stan::math::assign(powTrend, (((MAX_POW_TREND - MIN_POW_TREND) * powTrendBeta) + MIN_POW_TREND));
            for (int t = 2; t <= N; ++t) {

                stan::math::assign(get_base1_lhs(l,t,"l",1), (((levSm * get_base1(y,t,"y",1)) / get_base1(s,t,"s",1)) + ((1 - levSm) * get_base1(l,(t - 1),"l",1))));
                stan::math::assign(get_base1_lhs(s,(t + SEASONALITY),"s",1), (((sSm * get_base1(y,t,"y",1)) / get_base1(l,t,"l",1)) + ((1 - sSm) * get_base1(s,t,"s",1))));
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        check_greater_or_equal(function__,"powTrend",powTrend,MIN_POW_TREND);
        check_less_or_equal(function__,"powTrend",powTrend,MAX_POW_TREND);

        // write transformed parameters
        vars__.push_back(powTrend);
        for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(l[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < SEASONALITY; ++k_0__) {
            vars__.push_back(inits[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < (N + SEASONALITY); ++k_0__) {
            vars__.push_back(s[k_0__]);
        }
        vars__.push_back(sumsu);

        if (!include_gqs__) return;
        // declare and define generated quantities


        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate generated quantities

        // write generated quantities
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_sgt";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "nu";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "levSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powx";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrendBeta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "coefTrend";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "offsetSigma";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= SEASONALITY; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "initSu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrend";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "l" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= SEASONALITY; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "inits" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= (N + SEASONALITY); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "s" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sumsu";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "nu";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "levSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powx";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrendBeta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "coefTrend";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "offsetSigma";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= SEASONALITY; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "initSu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrend";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "l" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= SEASONALITY; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "inits" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= (N + SEASONALITY); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "s" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sumsu";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
    }

}; // model

}




// Code generated by Stan version 2.16.0

#include <stan/model/model_header.hpp>

namespace model_trend_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_trend");
    reader.add_event(40, 40, "end", "model_trend");
    return reader;
}

class model_trend : public prob_grad {
private:
    double CAUCHY_SD;
    double MIN_POW_TREND;
    double MAX_POW_TREND;
    double MIN_SIGMA;
    int N;
    vector_d y;
public:
    model_trend(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_trend(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_trend_namespace::model_trend";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        context__.validate_dims("data initialization", "CAUCHY_SD", "double", context__.to_vec());
        CAUCHY_SD = double(0);
        vals_r__ = context__.vals_r("CAUCHY_SD");
        pos__ = 0;
        CAUCHY_SD = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MIN_POW_TREND", "double", context__.to_vec());
        MIN_POW_TREND = double(0);
        vals_r__ = context__.vals_r("MIN_POW_TREND");
        pos__ = 0;
        MIN_POW_TREND = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MAX_POW_TREND", "double", context__.to_vec());
        MAX_POW_TREND = double(0);
        vals_r__ = context__.vals_r("MAX_POW_TREND");
        pos__ = 0;
        MAX_POW_TREND = vals_r__[pos__++];
        context__.validate_dims("data initialization", "MIN_SIGMA", "double", context__.to_vec());
        MIN_SIGMA = double(0);
        vals_r__ = context__.vals_r("MIN_SIGMA");
        pos__ = 0;
        MIN_SIGMA = vals_r__[pos__++];
        context__.validate_dims("data initialization", "N", "int", context__.to_vec());
        N = int(0);
        vals_i__ = context__.vals_i("N");
        pos__ = 0;
        N = vals_i__[pos__++];
        validate_non_negative_index("y", "N", N);
        context__.validate_dims("data initialization", "y", "vector_d", context__.to_vec(N));
        validate_non_negative_index("y", "N", N);
        y = vector_d(static_cast<Eigen::VectorXd::Index>(N));
        vals_r__ = context__.vals_r("y");
        pos__ = 0;
        size_t y_i_vec_lim__ = N;
        for (size_t i_vec__ = 0; i_vec__ < y_i_vec_lim__; ++i_vec__) {
            y[i_vec__] = vals_r__[pos__++];
        }

        // validate, data variables
        check_greater_or_equal(function__,"CAUCHY_SD",CAUCHY_SD,0);
        check_greater_or_equal(function__,"MIN_SIGMA",MIN_SIGMA,0);
        check_greater_or_equal(function__,"N",N,1);
        check_greater_or_equal(function__,"y",y,0);
        // initialize data variables

        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed data

        // validate, set parameter ranges
        num_params_r__ = 0U;
        param_ranges_i__.clear();
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
    }

    ~model_trend() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma", "double", context__.to_vec());
        // generate_declaration sigma
        double sigma(0);
        sigma = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(MIN_SIGMA,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("levSm")))
            throw std::runtime_error("variable levSm missing");
        vals_r__ = context__.vals_r("levSm");
        pos__ = 0U;
        context__.validate_dims("initialization", "levSm", "double", context__.to_vec());
        // generate_declaration levSm
        double levSm(0);
        levSm = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,levSm);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable levSm: ") + e.what());
        }

        if (!(context__.contains_r("bSm")))
            throw std::runtime_error("variable bSm missing");
        vals_r__ = context__.vals_r("bSm");
        pos__ = 0U;
        context__.validate_dims("initialization", "bSm", "double", context__.to_vec());
        // generate_declaration bSm
        double bSm(0);
        bSm = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,bSm);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable bSm: ") + e.what());
        }

        if (!(context__.contains_r("powTrendBeta")))
            throw std::runtime_error("variable powTrendBeta missing");
        vals_r__ = context__.vals_r("powTrendBeta");
        pos__ = 0U;
        context__.validate_dims("initialization", "powTrendBeta", "double", context__.to_vec());
        // generate_declaration powTrendBeta
        double powTrendBeta(0);
        powTrendBeta = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,powTrendBeta);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable powTrendBeta: ") + e.what());
        }

        if (!(context__.contains_r("coefTrend")))
            throw std::runtime_error("variable coefTrend missing");
        vals_r__ = context__.vals_r("coefTrend");
        pos__ = 0U;
        context__.validate_dims("initialization", "coefTrend", "double", context__.to_vec());
        // generate_declaration coefTrend
        double coefTrend(0);
        coefTrend = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(coefTrend);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable coefTrend: ") + e.what());
        }

        if (!(context__.contains_r("locTrendFract")))
            throw std::runtime_error("variable locTrendFract missing");
        vals_r__ = context__.vals_r("locTrendFract");
        pos__ = 0U;
        context__.validate_dims("initialization", "locTrendFract", "double", context__.to_vec());
        // generate_declaration locTrendFract
        double locTrendFract(0);
        locTrendFract = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(-(0.25),1,locTrendFract);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable locTrendFract: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        // model parameters
        stan::io::reader<T__> in__(params_r__,params_i__);

        T__ sigma;
        (void) sigma;  // dummy to suppress unused var warning
        if (jacobian__)
            sigma = in__.scalar_lb_constrain(MIN_SIGMA,lp__);
        else
            sigma = in__.scalar_lb_constrain(MIN_SIGMA);

        T__ levSm;
        (void) levSm;  // dummy to suppress unused var warning
        if (jacobian__)
            levSm = in__.scalar_lub_constrain(0,1,lp__);
        else
            levSm = in__.scalar_lub_constrain(0,1);

        T__ bSm;
        (void) bSm;  // dummy to suppress unused var warning
        if (jacobian__)
            bSm = in__.scalar_lub_constrain(0,1,lp__);
        else
            bSm = in__.scalar_lub_constrain(0,1);

        T__ powTrendBeta;
        (void) powTrendBeta;  // dummy to suppress unused var warning
        if (jacobian__)
            powTrendBeta = in__.scalar_lub_constrain(0,1,lp__);
        else
            powTrendBeta = in__.scalar_lub_constrain(0,1);

        T__ coefTrend;
        (void) coefTrend;  // dummy to suppress unused var warning
        if (jacobian__)
            coefTrend = in__.scalar_constrain(lp__);
        else
            coefTrend = in__.scalar_constrain();

        T__ locTrendFract;
        (void) locTrendFract;  // dummy to suppress unused var warning
        if (jacobian__)
            locTrendFract = in__.scalar_lub_constrain(-(0.25),1,lp__);
        else
            locTrendFract = in__.scalar_lub_constrain(-(0.25),1);


        // transformed parameters
        T__ powTrend;
        (void) powTrend;  // dummy to suppress unused var warning

        stan::math::initialize(powTrend, DUMMY_VAR__);
        stan::math::fill(powTrend,DUMMY_VAR__);
        validate_non_negative_index("l", "N", N);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  l(static_cast<Eigen::VectorXd::Index>(N));
        (void) l;  // dummy to suppress unused var warning

        stan::math::initialize(l, DUMMY_VAR__);
        stan::math::fill(l,DUMMY_VAR__);
        validate_non_negative_index("b", "N", N);
        Eigen::Matrix<T__,Eigen::Dynamic,1>  b(static_cast<Eigen::VectorXd::Index>(N));
        (void) b;  // dummy to suppress unused var warning

        stan::math::initialize(b, DUMMY_VAR__);
        stan::math::fill(b,DUMMY_VAR__);


        try {
            stan::math::assign(get_base1_lhs(l,1,"l",1), get_base1(y,1,"y",1));
            stan::math::assign(get_base1_lhs(b,1,"b",1), 0);
            stan::math::assign(powTrend, (((MAX_POW_TREND - MIN_POW_TREND) * powTrendBeta) + MIN_POW_TREND));
            for (int t = 2; t <= N; ++t) {

                stan::math::assign(get_base1_lhs(l,t,"l",1), ((levSm * get_base1(y,t,"y",1)) + ((1 - levSm) * get_base1(l,(t - 1),"l",1))));
                stan::math::assign(get_base1_lhs(b,t,"b",1), ((bSm * (get_base1(l,t,"l",1) - get_base1(l,(t - 1),"l",1))) + ((1 - bSm) * get_base1(b,(t - 1),"b",1))));
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        if (stan::math::is_uninitialized(powTrend)) {
            std::stringstream msg__;
            msg__ << "Undefined transformed parameter: powTrend";
            throw std::runtime_error(msg__.str());
        }
        for (int i0__ = 0; i0__ < N; ++i0__) {
            if (stan::math::is_uninitialized(l(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: l" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < N; ++i0__) {
            if (stan::math::is_uninitialized(b(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: b" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }

        const char* function__ = "validate transformed params";
        (void) function__;  // dummy to suppress unused var warning
        check_greater_or_equal(function__,"powTrend",powTrend,MIN_POW_TREND);
        check_less_or_equal(function__,"powTrend",powTrend,MAX_POW_TREND);

        // model body
        try {

            lp_accum__.add(cauchy_log<propto__>(sigma, MIN_SIGMA, CAUCHY_SD));
            if (sigma < MIN_SIGMA) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-cauchy_ccdf_log(MIN_SIGMA, MIN_SIGMA, CAUCHY_SD));
            lp_accum__.add(cauchy_log<propto__>(coefTrend, 0, CAUCHY_SD));
            for (int t = 2; t <= N; ++t) {

                lp_accum__.add(normal_log<propto__>(get_base1(y,t,"y",1), ((get_base1(l,(t - 1),"l",1) + (coefTrend * pow(fabs(get_base1(l,(t - 1),"l",1)),powTrend))) + (locTrendFract * get_base1(b,(t - 1),"b",1))), sigma));
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("sigma");
        names__.push_back("levSm");
        names__.push_back("bSm");
        names__.push_back("powTrendBeta");
        names__.push_back("coefTrend");
        names__.push_back("locTrendFract");
        names__.push_back("powTrend");
        names__.push_back("l");
        names__.push_back("b");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_trend_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double sigma = in__.scalar_lb_constrain(MIN_SIGMA);
        double levSm = in__.scalar_lub_constrain(0,1);
        double bSm = in__.scalar_lub_constrain(0,1);
        double powTrendBeta = in__.scalar_lub_constrain(0,1);
        double coefTrend = in__.scalar_constrain();
        double locTrendFract = in__.scalar_lub_constrain(-(0.25),1);
        vars__.push_back(sigma);
        vars__.push_back(levSm);
        vars__.push_back(bSm);
        vars__.push_back(powTrendBeta);
        vars__.push_back(coefTrend);
        vars__.push_back(locTrendFract);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        double powTrend(0.0);
        (void) powTrend;  // dummy to suppress unused var warning

        stan::math::initialize(powTrend, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(powTrend,DUMMY_VAR__);
        validate_non_negative_index("l", "N", N);
        vector_d l(static_cast<Eigen::VectorXd::Index>(N));
        (void) l;  // dummy to suppress unused var warning

        stan::math::initialize(l, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(l,DUMMY_VAR__);
        validate_non_negative_index("b", "N", N);
        vector_d b(static_cast<Eigen::VectorXd::Index>(N));
        (void) b;  // dummy to suppress unused var warning

        stan::math::initialize(b, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(b,DUMMY_VAR__);


        try {
            stan::math::assign(get_base1_lhs(l,1,"l",1), get_base1(y,1,"y",1));
            stan::math::assign(get_base1_lhs(b,1,"b",1), 0);
            stan::math::assign(powTrend, (((MAX_POW_TREND - MIN_POW_TREND) * powTrendBeta) + MIN_POW_TREND));
            for (int t = 2; t <= N; ++t) {

                stan::math::assign(get_base1_lhs(l,t,"l",1), ((levSm * get_base1(y,t,"y",1)) + ((1 - levSm) * get_base1(l,(t - 1),"l",1))));
                stan::math::assign(get_base1_lhs(b,t,"b",1), ((bSm * (get_base1(l,t,"l",1) - get_base1(l,(t - 1),"l",1))) + ((1 - bSm) * get_base1(b,(t - 1),"b",1))));
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        check_greater_or_equal(function__,"powTrend",powTrend,MIN_POW_TREND);
        check_less_or_equal(function__,"powTrend",powTrend,MAX_POW_TREND);

        // write transformed parameters
        vars__.push_back(powTrend);
        for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(l[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(b[k_0__]);
        }

        if (!include_gqs__) return;
        // declare and define generated quantities


        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate generated quantities

        // write generated quantities
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_trend";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "levSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "bSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrendBeta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "coefTrend";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "locTrendFract";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrend";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "l" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "levSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "bSm";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrendBeta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "coefTrend";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "locTrendFract";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "powTrend";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "l" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "b" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
    }

}; // model

}




#endif
